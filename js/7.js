// ---------------------------------------------DOM-------------------------------------------
// Властивості та атрибути
// Доступ до властивостей
// Під час побудови DOM-дерева деякі стандартні HTML-атрибути стають властивостями елементів, тобто властивостями DOM-об’єктів.
// Розберемо приклад:
// Якщо в HTML є тег посилання,
// a class="link" href="https://goit.global">
//   GoIT
// /a;
// то у JavaScript коді можна прочитати значення його атрибута href, отримавши посилання на елемент,
//     тобто об'єкт, використовуючи querySelector, і звернутися до його властивості href
// const link = document.querySelector('.link');
// console.log(link.href); // "https://goit.global"

// Значення атрибутів можна змінювати, перевизначивши їм нове значення прямо з JavaScript коду,
// і під час виконання скрипта значення в HTML, тобто в DOM - дереві, зміниться.

// const link = document.querySelector('.link');
// console.log(link.href); // "https://goit.global"
// link.href = 'https://neo.goit.global';
// console.log(link.href); // "https://neo.goit.global"
// -------------------------------------------------------------------------------------------
//                                Властивість textContent
// Властивість textContent повертає весь текстовий контент усередині елементів (власних і вкладених елементів).
// <p class="text">Username: <span class=”sub-text”>Mango</span></p>
// Для отримання текстового контенту елемента, як завжди, отримуємо посилання на елемент і звертаємося до властивості через крапку.

// const el = document.querySelector(".text")
// const nested = document.querySelector(".sub-text")

// console.log(el.textContent); // "Username: Mango"
// console.log(nested.textContent); // "Mango"

// Властивість textContent можна як читати, так і змінювати.
//     Неважливо, що буде передано в textContent, дані завжди будуть записані як текст.

// const el = document.querySelector(".text")
// console.log(el.textContent); // "Username: Mango"
// el.textContent = "Username: Poly";
// -------------------------------------------------------------------------------------------------------
//                                      Властивість classList
// Для того щоб із JavaScript коду прочитати, додати, видалити або перевірити наявність CSS - класу в елемента,
// у властивості classList зберігається об'єкт із методами для роботи з CSS-класами елемента.

// <a class="link is-active" href="https://goit.global">GoIT</a>
// Властивість classList — це спеціальний тип об’єкта, який подібний до масиву.
// Зверни увагу, що він схожий, але не є нативним JavaScript - масивом, який ми вивчали раніше.
// Він зберігає в собі весь перелік класів DOM - елемента, властивість length і властивість value.

// властивість value містить точне значення атрибута class
// властивість length — кількість класів в елемента

// Але самі по собі value та length майже не використовуються, тому що для операцій з класами
//  (додавання, видалення тощо) є спеціальні методи.

// const link = document.querySelector(".link");
// console.log(link.classList);
// ["link", "is-active", length: 2, value: "link is-active"]

//                            Метод classList.contains(className)

// Метод очікує аргументом рядок з іменем класу та повертає true або false, залежно від наявності класу className в елемента.
// Зверни увагу, що className передаємо як рядок без крапки (без селектора класу).

// const hasActiveClass = link.classList.contains("is-active"); // true
// const hasActiveClass = link.classList.contains("title"); // false

//                          Метод classList.add(className)

// Метод очікує аргументом рядок з іменем класу та додає клас className до списку класів елемента.

// link.classList.add("special");
// console.log(link.classList);
// ["link", "is-active", "special", length: 3, value: "link is-active special"]
// Можна додавати більше одного класу, вказавши кілька аргументів через кому.

//                         Метод classList.remove(className)

// Метод очікує аргументом рядок з іменем класу та видаляє клас className зі списку класів елемента.

// link.classList.remove("is-active");
// console.log(link.classList);
// ["link", "special", length: 2, value: "link special"]
// Якщо спробувати видалити клас, якого не існує на елементі, то це не викличе помилку. Просто нічого не видалиться.

//                             Метод classList.toggle(className)

// Метод працює як перемикач:
// якщо клас className відсутній, то додає його в кінець списку класів
// і навпаки, якщо клас className присутній — видаляє його
// link.classList.toggle("is-active");
// console.log(link.classList);
// ["link", "special", "is-active", length: 3, value: "link special is-active"]

//                            Метод classList.replace(oldClassName, newClassName)

// Метод очікує 2 аргументи рядка(перший — стара назва класу, другий — нова назва класу)
// та замінює існуючий клас oldClassName на вказаний newClassName.

// link.classList.replace("special", "regular");
// console.log(link.classList);
// ["link", "regular", "is-active", length: 3, value: "link regular is-active"]
// Якщо спробувати поміняти клас, якого не існує на елементі, то це не викличе помилку.Просто нічого не поміняється.
// ------------------------------------------------------------------------------------------------------------------
//                                     Властивість style

// Властивість style використовується для читання та зміни вбудованих стилів з DOM - елементів.
// Вона повертає об'єкт, який містить список лише всіх вбудованих властивостей елемента, а не увесь CSS.
// Під час запису властивості вони записуються в camelCase нотації, замість дефісів, які зазвичай використовуються в CSS,
// тобто background - color перетворюється на backgroundColor.

// const button = document.querySelector(".btn");

// button.style.backgroundColor = "teal";
// button.style.fontSize = "24px";
// button.style.textAlign = "center";

// console.log(button.style); // inline styles object

// На практиці стилізація елементів зазвичай виконується шляхом додавання CSS-класів.
// Властивість style використовується для додавання будь - яких динамічних стилів, наприклад,
// якщо посилання на фонове зображення невідомо заздалегідь і приходить з бекенда.
// -------------------------------------------------------------------------------------------------------------------
//                                     Доступ до атрибутів

// DOM-елементам відповідають HTML-теги, які містять текстові атрибути.
// Доступ до атрибутів здійснюється за допомогою стандартних методів. Ці методи працюють зі значенням, яке знаходиться в HTML.

// <img class="image" src="https://picsum.photos/id/15/320/240" alt="Rocks and waterfall" width="300" />

//                              Метод element.hasAttribute(nameAttribute)

// Метод приймає один аргумент — рядок nameAttribute, який містить ім’я атрибута для перевірки та повертає
//  результат перевірки його наявності на елементі element — true чи false.

// const image = document.querySelector(".image");
// console.log(image.hasAttribute("src")); // true
// console.log(image.hasAttribute("href")); // false

//                             Метод element.getAttribute(nameAttribute)

// Метод отримує один аргумент — рядок nameAttribute з іменем атрибута, і повертає значення цього атрибута
// для вказаного HTML - елемента element.Якщо атрибут не знайдено, метод повертає null.

// console.log(image.getAttribute("alt")); // "Rocks and waterfall"

//                             Метод element.setAttribute(nameAttribute, value)

// Метод приймає два аргументи: рядок nameAttribute з іменем атрибута, який потрібно встановити або змінити,
// та value зі значенням, яке цьому атрибуту треба присвоїти.Метод встановлює або змінює значення зазначеного
// атрибута для вказаного HTML - елемента element.

// image.setAttribute("alt", "Amazing nature");
// console.log(image.getAttribute("alt")); // Amazing nature

//                            Метод element.removeAttribute(nameAttribute)

// Метод приймає один аргумент — рядок nameAttribute з іменем атрибута, який потрібно видалити зі вказаного HTML - елемента
// element — та видаляє його.Якщо зазначеного атрибута немає на елементі, метод не викликає жодних помилок та не робить нічого.

// image.removeAttribute("alt");
// console.log(image.hasAttribute("alt")); // false

// Отримати доступ або змінити значення деяких атрибутів елемента можна безпосередньо,
// звернувшись до них як до властивостей DOM - об'єкта. Це буде менш затратно за кількістю коду.
// А ось видалити або перевірити наявність буде зручніше, використовуючи відповідний метод.
// У живому прикладі ми працюємо із зображенням і його атрибутами.
// ---------------------------------------------------------------------------------------------------
//    Власні атрибути

// Специфікацією HTML визначено вичерпний перелік атрибутів, які ми можемо додавати на ті чи інші теги(DOM - елементи)
//  для того, щоб розмітка лишалась валідною, але інколи цього переліку недостатньо.Бувають випадки, коли нам потрібно
//  зберегти певну інформацію на тезі, наприклад, вказати тип дії кнопки, щоб потім у певний момент часу мати можливість
//  отримати до неї доступ.І тут на допомогу приходять власні data - атрибути.
// Власні атрибути дозволяють додати до тегу довільний атрибут і отримати його значення в JavaScript.

// button type="button" data-action="save">Save text</button>
// button type="button" data-action="close">Close editor</button>

// Отримання значень
// Для отримання значення data - атрибута використовується властивість dataset,
// після якої через крапку пишеться ім'я атрибута без data-. Тобто data- відкидається,
// а інша частина імені записується як ім'я властивості об'єкта.

// const saveBtn = document.querySelector('button[data-action="save"]');
// console.log(saveBtn.dataset.action); // "save"

// const closeBtn = document.querySelector('button[data-action="close"]');
// console.log(closeBtn.dataset.action); // "close"

// Зміна значень

// Змінити значення існуючого data - атрибута або додати новий можна так само, як і будь - якої іншої властивості
// об'єкта в JavaScript. Щоб це зробити, треба отримати доступ до DOM-елемента, а потім змінити/задати значення властивості
// в об'єкті dataset.

// // Змінюємо значення data-action для кнопки saveBtn
// saveBtn.dataset.action = "update";

// // Додаємо новий data-атрибут data-role
// saveBtn.dataset.role = "admin";

// // Перевіримо нові значення
// console.log(saveBtn.dataset.action); // "update"
// console.log(saveBtn.dataset.role); // "admin"
// Тепер data-action атрибут для saveBtn має значення "update" замість "save".
// ------------------------------------------------------------------------------------------------------
//                                 Створення та видалення елементів
// Створення елементів
// DOM API (Document Object Model Application Programming Interface) має широкий функціонал. За його допомогою можна:
// вибирати або змінювати вже існуючі елементи
// видаляти елементи
// створювати нові елементи й додавати їх у документ

// Розглянемо, як створити новий елемент:

// document.createElement(tagName)
// створює елемент з ім'ям tagName і повертає посилання на його об’єкт як результат свого виконання.
// tagName — це рядок, що вказує тип елемента, який створюється.
// Елемент створюється в пам'яті, у DOM його ще немає.

// const heading = document.createElement("h1");

// Після створення елемента heading отримуємо посилання на його об’єкт у пам'яті.
//  З цього моменту можна звертатися до властивостей цього об’єкта і змінювати їх ще до того, як вставимо цей елемент у DOM.

// const heading = document.createElement('h1');
// headding.classList.add('title');
// heading.textContent = 'This is a heading';
// console.log(heading); // <h1 class="title">This is a heading</h1>

// const image = document.createElement('img');
// image.src = 'https://picsum.photos/id/11/320/240';
// image.alt = 'Nature';
// console.log(image); // <img src="https://picsum.photos/id/11/320/240" alt="Nature" />
// ----------------------------------------------------------------------------------------------------------------------
//                                         Додавання елементів

// Щоб створений елемент відображався на сторінці, його необхідно додати до вже існуючого елемента в DOM - дереві.
//     Припустимо, що додаємо до певного елемента elem, для цього існують такі методи.

// elem.append(el1, el2, ...) — додає один або декілька елементів після всіх дітей елемента elem.
// elem.prepend(el1, el2, ...) — додає один або декілька елементів перед усіма дітьми елемента elem.
// У всіх цих методах el — це елементи або рядки, у будь-якому поєднанні та кількості. Рядки додаються, як текстові вузли.

// Зверни увагу! Якщо елемент для додавання вже знаходиться в DOM, то він видаляється зі свого старого місця й додається у нове.
//     Отже, є правило: один і той самий елемент не може бути одночасно у двох місцях.
// --------------------------------------------------------------------------------------------------------------------------
//                                   Видалення елементів
// Для того щоб видалити елемент, використовується метод element.remove().
// <p class="text">Random text content</p>
// Він викликається на елементі element, який необхідно видалити.
// const text = document.querySelector(".text")
// text.remove();
// У живому прикладі ми видаляємо елемент тексту зі статті.
// -----------------------------------------------------------------------------------------------------------------------------
//                                            Властивість innerHTML

// Існує ще один спосіб створити DOM-елементи і помістити їх у DOM-дерево.

// Для цього треба використати рядки з тегами і дозволити браузеру зробити всю важку роботу.
//  У такого підходу є свої плюси та мінуси.

// Читання
// Властивість innerHTML зберігає вміст елемента, включно з тегами, у вигляді рядка.
//     Значення, що повертається, — це завжди валідний HTML - код.

// Зміна
// Властивість innerHTML доступна і для читання, і для запису.
// Якщо записати в неї рядок з HTML - тегами, то браузер під час парсингу рядка перетворить
//  його у валідні елементи і додасть у DOM - дерево.

// Якщо у властивість innerHTML записати порожній рядок, то вміст елемента буде очищено.
//  Це простий і швидкий спосіб видалення всього вмісту.

// Однотипна (шаблонна) розмітка створюється із масиву даних.
// Прийом полягає в перебиранні цього масиву та створенні одного рядка з HTML - тегами,
//     який потім записуємо в innerHTML елемента.Якщо ти будеш це робити за допомогою методу map(),
//     не забудь, що він повертає масив.Отже, перед тим як додавати розмітку в DOM, цей масив треба
//          привести до рядка за допомогою методу join()

// Нове значення для element.innerHTML повністю видалить і повторно створить усіх нащадків елемента element.
//  Якщо елемент спочатку не був порожній, то виникнуть додаткові витрати на повторне створення вже існуючої розмітки, а це погано.

// Використовуй властивість element.innerHTML для додавання тільки у разі,
// — коли елемент element порожній або
// — якщо потрібно повністю замінити вміст element
// -----------------------------------------------------------------------------------------------------------
//                                        Метод insertAdjacentHTML()

// Метод insertAdjacentHTML() — це сучасний метод для додавання рядка з HTML - тегами перед, після або всередину елемента.
// Він вирішує проблему innerHTML з повторною серіалізацією вмісту елемента під час додавання розмітки до вже існуючої.

// element.insertAdjacentHTML(position, string)
// Аргумент position — це рядок, який визначає позицію щодо елемента element. Він приймає одне з чотирьох значень.

// "beforebegin" — перед element
// "afterbegin" — всередині element, перед усіма дітьми
// "beforeend" — всередині element, після усіх дітей
// "afterend" — після element
// Значення "beforebegin" і "afterend" працюють тільки тоді, коли element вже знаходиться в DOM - дереві.
//  Обмеження зумовлене тим, що неможливо дізнатися, куди вставляти розмітку, доти, доки елемент не буде перебувати в DOM - дереві.
// У живому прикладі спочатку в HTML є список із трьох елементів.
//  Ще три ми додаємо через JavaScript, використовуючи метод insertAdjacentHTML, так само як і заголовок списку.
// --------------------------------------------------------------------------------------------------------------------
//                                                  Події
// Метод addEventListener()
// Подія — це сигнал від браузера про те, що на вебсторінці щось відбулося.
// Існує багато видів подій: події миші, події клавіатури, події елементів форм, зміни розмірів вікна,
//     завантаження зображень, буфера обміну, зміни стадії CSS анімації або переходу тощо.
//     Події використовуються для реакції на дії користувача й виконання коду, пов'язаного з певною подією.

// Для того щоб елемент реагував на дії користувача, до нього необхідно додати слухача події та визначити йому обробника.

// Слухач події — це механізм, який "слухає" або "очікує" на виникнення певної події.
//  Метод addEventListener() додає слухача події на елемент.

// element.addEventListener(event, handler, options)

// Аргументи методу:

// event — рядок, що містить ім'я події, наприклад, "click"
// handler — колбек-функція, яка буде викликана під час настання події
// options — необов'язковий об'єкт параметрів із розширеними налаштуваннями
// Давай розглянемо приклад. У тебе на сайті є кнопка для перегортання галереї зображень.

// 1.В HTML є кнопка з класом my-button.
// <button class="my-button">Next</button>
//     2.Щоб галерея горталась, тобі потрібно в JavaScript коді отримати посилання на елемент
// кнопки й додати на нього слухача події кліку.
// const button = document.querySelector(".my-button");

// button.addEventListener("click", () => {
//   console.log("The button was pressed and now the next image will appear");
// });

// У виклик addEventListener() першим аргументом ми передали ім’я події "click",
// другим — функцію - обробник подій(event handler) — () => { console.log("...") }.
//  Кожного разу, коли на елементі button відбуватиметься подія "click", ця колбек - функція буде виконуватися
//   й виводити в консоль повідомлення "The button was pressed and now the next image will appear".

// Для колбека можна використовувати не анонімну, а окрему функцію, передаючи на неї посилання, як це реалізовано у прикладі нижче.
//  Іменована функція підвищує читабельність коду.

// const button = document.querySelector('.my-button');

// const handleClick = () => {
//   console.log('The button was pressed and now the next image will appear');
// };

// button.addEventListener('click', handleClick);

// На одному елементі може бути будь - яка кількість обробників подій, навіть подій одного типу.
//     Колбек - функції будуть викликатися в порядку їхньої реєстрації в коді.
// ------------------------------------------------------------------------------------------------------------------------------
//                                               Метод removeEventListener()

// removeEventListener() видаляє слухача події з елемента.
// Аргументи аналогічні методу addEventListener():
// element.removeEventListener(event, handler, options)
// Для того щоб мати можливість видаляти слухача події з елемента через removeEventListener,
//     важливо використовувати ту саму функцію - обробник, яка була призначена в addEventListener.
//     З цієї причини рекомендовано для обробників подій використовувати іменовані функції, які можна легко передавати як аргументи

// const button = document.querySelector(".my-button");

// const handleClick = () => {
//   console.log("The button was pressed and now the next image will appear");
// };

// button.addEventListener("click", handleClick);
// Розбери живий приклад, у якому на кнопку з текстом Click me додається й видаляється слухач події іншими двома кнопками.
//  При кліках по кнопках у консоль розробника виводяться повідомлення.
// ----------------------------------------------------------------------------------------------------------------------
//                                            Об'єкт події
// Для обробки події недостатньо знати, що подія — це клік або натискання клавіші.
// Розробнику можуть знадобитися інші деталі, а саме: елемент, на якому відбулася подія,
//     його поточне значення текстового поля, вбудовані методи тощо.

// Кожна подія — це об'єкт, який містить інформацію про деталі події та автоматично передається
//  першим аргументом в обробник події.Усі події відбуваються з базового класу Event.

// const handleClick = event => {
//   console.log(event);
// };

// button.addEventListener("click", handleClick);
// Параметр event — це і є об'єкт події, який автоматично передається першим аргументом під час виклику колбек-функції.
// Ми можемо називати його як завгодно, але, як правило, його оголошують як e, evt або event.

// Деякі властивості об'єкта події:
// event.type — тип події.
// event.currentTarget — елемент, на якому виконується обробник події.
// Відкрий живий приклад і подивись на об’єкт події в консолі розробника при кліку.
// ---------------------------------------------------------------------------------------------------------------------------
//                                                Події клавіатури

// Існує дві основні події клавіатури:
// keydown — подія, що відбувається при натисканні клавіші
// keyup — подія, що відбувається, коли клавішу відпустили
// На відміну від інших подій, події клавіатури обробляються на документі, а не на конкретному елементі.
//     Об'єкти подій клавіатури походять від базового класу KeyboardEvent.

// document.addEventListener("keydown", event => {
//   console.log("Keydown: ", event);
// });

// document.addEventListener("keyup", event => {
//   console.log("Keyup: ", event);
// });

// Події keydown і keyup спрацьовують при натисканні будь-якої клавіші, включно зі службовими (Ctrl, ShiftAltEscape тощо).

// На практиці переважно обробляють тільки подію keydown, оскільки вона відбувається швидше за keyup
//  і користувач раніше бачить результат натискання.
// -----------------------------------------------------------------------------------------------------------------------------
//                                            Властивості key і code
// Властивість об’єкта події key повертає символ, згенерований натисканням клавіші на клавіатурі. Ця властивість враховує:
// стан клавіш-модифікаторів, наприклад Shift
// поточну мову
// Властивість об’єкта події code повертає код фізичної клавіші на клавіатурі й не залежить від мови та стану клавіш-модифікаторів.

// document.addEventListener("keydown", event => {
//   console.log("key: ", event.key);
//   console.log("code: ", event.code);
// });
// Код у живому прикладі створює простий журнал подій для подій "keydown" і "keyup”. Клікни мишею по вікну з прикладом,
//  щоб навести на нього фокус.Відстеження подій клавіатури вже знаходиться на елементі document.Надрукуй щось на клавіатурі,
//     щоб побачити результат їх обробки.
// ---------------------------------------------------------------------------------------------------------------------------------
//                                                  Події елементів форм
// Подія submit
// Відправлення форми відбувається:
// при кліку на кнопку з атрибутом type="submit"
// Або
// при натисканні клавіші Enter під час перебування в будь-якому її текстовому полі форми

// Подія submit відбувається безпосередньо на формі (тег form), тому обробник подій слід встановлювати саме на ній.

// const form = document.querySelector("form");

// form.addEventListener("submit", event => {
// 	// ...
// });

// Деякі події викликають дію браузера, вбудовану за замовчуванням як реакція на певний тип події.
//     Наприклад, клік на посиланні ініціює перехід на нову адресу, зазначену в href, а відправлення форми перезавантажує сторінку.
// Найчастіше ця поведінка небажана і її необхідно скасувати.
//  Для скасування дії браузера за замовчуванням в об'єкта події є стандартний метод preventDefault().

// const form = document.querySelector("form");

// form.addEventListener("submit", event => {
// 	event.preventDefault();
// });
// Подію submit можна застосувати для валідації(перевірки) форми перед відправленням,
//     оскільки на об'єкті події існує багато корисних властивостей, пов'язаних з елементами форми.
// Властивість elements DOM - елемента форми містить об'єкт з посиланнями на всі її елементи, які мають атрибут name.
// Саме тому в прикладі ми отримуємо значення полів, звертаючись до event.target.elements.login.value і event.target.elements.password.value.
// --------------------------------------------------------------------------------------------------------
//                                              Подія change
// Подія change відбувається після зміни елемента форми.
// Для текстових полів або textarea подія відбудеться не на кожному введенні символу, а після втрати фокусу.
//  Це не завжди зручно.Уяви, що користувач набирає щось у текстовому полі — подія відсутня.Щойно фокус пропав, відбудеться подія change.

// Для інших елементів, наприклад, select, чекбоксів і радіокнопок, подія change спрацьовує відразу під час вибору значення.

// Зверни увагу на корисні властивості при роботі з елементом <select> у прикладі.

// Визнач, що зберігається у властивостях value, selectedIndex і options.
// ---------------------------------------------------------------------------------------.
//                                                 Подія input
// Подія input відбувається тільки на текстових полях і textarea.

// Вона створюється щоразу при зміні значення елемента, не чекаючи втрати фокусу.
// На практиці input — це найголовніша подія для роботи з текстовими полями форми.

// Порівняємо події input і change на текстових полях і textarea

// Подія input:

// відбувається при кожній зміні значення (при введенні або видаленні)
// не залежить від втрати фокусу

// Подія change:

// відбувається після втрати фокусу за умови, що відбулася зміна значення в елементі
// --------------------------------------------------------------------------------------------------------
//                                    Подія focus і blur

// Елемент отримує фокус під час кліку миші або переходу клавішею Tab.
// Момент отримання і втрати фокусу дуже важливий.Отримуючи фокус, ми можемо завантажити дані для автозаповнення,
//     почати відстежувати зміни тощо.
// Під час втрати фокусу — перевірити введені дані.
// подія focus відбувається під час фокусування на елементі
// подія blur відбувається при втраті фокусу, наприклад, користувач клікає в іншому місці екрана

// Активувати або скасувати фокус можна програмно. Для цього треба викликати в коді для елемента однойменні методи focus() і blur().

// Розглянь, як реалізуються події focus та blur у живому прикладі.
// Фокус може бути тільки на одному елементі сторінки за одиницю часу.
// Поточний елемент, на якому знаходиться фокус, доступний як document.activeElement.
// Більшість елементів не можуть отримати фокус.Наприклад, якщо клікнути по < div >,
//     то фокусування на ньому не відбудеться, тому що це не інтерактивний елемент.
// ---------------------------------------------------------------------------------------------------------------
//                                       Підсумкова пам'ятка
// Згадаємо та підсумуємо основні методи і властивості DOM - елементів, з якими ми будемо працювати далі:

// Пошук DOM-елементів
// element.querySelector(selector) - повертає перший елемент, який відповідає вказаному CSS селектору всередині елемента element.
//     element.querySelectorAll(selector) - повертає всі елементи, які відповідають вказаному CSS селектору всередині елемента element.

// Властивості DOM-елемента
// element.textContent - містить текстовий вміст елемента element, ігноруючи всі теги HTML всередині.
// element.innerHTML - містить HTML-вміст елемента element.
// element.style - об'єкт, що містить вбудовані стилі елемента element, які можна змінювати динамічно з JavaScript.

// CSS класи на DOM-елементах
// element.classList.contains(className) - перевіряє, чи міститься вказаний клас className на елементі element.
// element.classList.add(className) - додає клас className до списку класів елемента element.
// element.classList.remove(className) - видаляє клас className зі списку класів елемента element.
// element.classList.toggle(className) - додає клас className, якщо його немає, або видаляє, якщо він вже присутній, на елементі element.
// element.classList.replace(oldClassName, newClassName) - замінює клас oldClassName на newClassName в списку класів елемента element.

// Створення та видалення DOM-елементів
// document.createElement(tagName) - створює новий HTML-елемент з вказаним ім'ям тегу tagName.
// element.append(el) - додає вміст (або елемент) до кінця списку дочірніх елементів element.
// element.prepend(el) - додає вміст (або елемент) до початку списку дочірніх елементів element.
// element.remove() - видаляє DOM-елемент з DOM дерева.
// insertAdjacentHTML(position, string) - додає вказаний рядок HTML після, перед, всередині або перед вказаним елементом.

// Події
// element.addEventListener(event, handler) - додає обробник події handler для події event на елемент element.
// element.removeEventListener(event, handler) - видаляє обробник події handler для події event на елементі element.
// keydown - подія, яка виникає, коли клавіша на клавіатурі натиснута.
// submit - подія, яка виникає при відправці форми.
// change - подія, яка виникає при зміні значення елемента форми.
// input - подія, яка виникає при введенні даних в текстове поле.
// focus - подія, яка виникає, коли елемент отримує фокус.
// blur - подія, яка виникає, коли елемент втрачає фокус.
// --------------------------------------------------------------------------------------------------------------------
// З використанням властивостей і методів DOM-елементів, напиши скрипт, який:

// Порахує й виведе в консоль кількість категорій в ul#categories, тобто елементів li.item.
// Для кожного елемента li.item у списку ul#categories знайде й виведе в консоль текст заголовка елемента(тегу < h2 >)
//  і кількість елементів у категорії(усіх < li >, вкладених у нього).

// На що буде звертати увагу ментор при перевірці:

// Кількість категорій, їх назва та кількість елементів отримані за допомогою властивостей і методів DOM-елементів
// Дані за кожною категорією були отримані й виведені в консоль у тілі циклу або методу forEach()
// Знаходимо ul#categories
// const categoriesList = document.querySelector('#categories');

// Отримуємо всі елементи li з класом 'item'
// const categoryItems = categoriesList.querySelectorAll('.item');

// Виводимо кількість категорій
// console.log(`Number of categories: ${categoryItems.length}`);

// Перебираємо кожен елемент li.item
// categoryItems.forEach((item) => {
// Знаходимо та виводимо заголовок h2 всередині елемента li.item
//   const categoryTitle = item.querySelector('h2').textContent;
// Знаходимо всі вкладені елементи li і виводимо їх кількість
//   const categoryElements = item.querySelectorAll('ul li').length;

//   console.log(`Category: ${categoryTitle}`);
//   console.log(`Elements: ${categoryElements}`);
// });
// -----------------------------------------------------------------------------------------------------
// Напиши скрипт для створення галереї зображень на основі масиву даних. HTML містить список ul.gallery.

// <ul class="gallery"></ul>
// Використовуй масив об'єктів images для створення елементів <img>, вкладених в <li>.
// Ти можеш створити й додати HTML - елементи, використовуючи document.createElement()
//  і elem.append() або шаблонні рядки і elem.insertAdjacentHTML().
// Усі елементи галереї повинні додаватися в DOM за одну операцію додавання.
// Додай мінімальне оформлення галереї флексбоксами через CSS класи.

// const images = [
//   {
//     url: 'https://images.pexels.com/photos/140134/pexels-photo-140134.jpeg?dpr=2&h=750&w=1260',
//     alt: 'White and Black Long Fur Cat',
//   },
//   {
//     url: 'https://images.pexels.com/photos/213399/pexels-photo-213399.jpeg?dpr=2&h=750&w=1260',
//     alt: 'Orange and White Koi Fish Near Yellow Koi Fish',
//   },
//   {
//     url: 'https://images.pexels.com/photos/219943/pexels-photo-219943.jpeg?dpr=2&h=750&w=1260',
//     alt: 'Group of Horses Running',
//   },
//   {
//     url: 'https://cdn.pixabay.com/photo/2019/05/17/09/27/the-alps-4209272_1280.jpg',
//     alt: 'Alpine Spring Meadows',
//   },
//   {
//     url: 'https://cdn.pixabay.com/photo/2019/05/16/21/10/landscape-4208255_1280.jpg',
//     alt: 'Nature Landscape',
//   },
//   {
//     url: 'https://cdn.pixabay.com/photo/2019/05/17/04/35/lighthouse-4208843_1280.jpg',
//     alt: 'Lighthouse Coast Sea',
//   },
// ];
// // Знаходимо елемент ul.gallery
// const gallery = document.querySelector('.gallery');

// // Створюємо шаблон для кожного зображення
// const galleryItems = images
//   .map(
//     (image) =>
//       `<li class="gallery-item"><img src="${image.url}" alt="${image.alt}" width="300"></li>`
//   )
//   .join('');

// // Додаємо всі елементи за одну операцію в DOM
// gallery.insertAdjacentHTML('beforeend', galleryItems);
// ----------------------------------------------------------------------------------------------
// Напиши скрипт, який під час набору тексту в інпуті input#name - input(подія input)
// підставляє його поточне значення в span#name - output як ім’я для привітання.
// Обов’язково очищай значення в інпуті по краях від пробілів.Якщо інпут порожній або містить лише пробіли,
// то замість імені у спан має підставлятися рядок "Anonymous".

// <input type="text" id="name-input" placeholder="Please enter your name" />
// <h1>Hello, <span id="name-output">Anonymous</span>!</h1>

// На що буде звертати увагу ментор при перевірці:

// На елементі input#name-input прослуховується подія input
// Під час набору тексту в інпуті його поточне значення підставляється в span#name-output як ім’я для привітання
// Значення в інпуті очищене від пробілів по краях
// Якщо інпут порожній або містить лише пробіли, то замість імені у спан має підставлятися рядок "Anonymous"

// const nameInput = document.getElementById('name-input');
// const nameOutput = document.getElementById('name-output');

// nameInput.addEventListener('input', () => {
//   // Отримуємо значення з інпуту та обрізаємо пробіли
//   const name = nameInput.value.trim();

//   // Перевіряємо, чи ім'я не пусте
//   if (name) {
//     nameOutput.textContent = name;
//   } else {
//     nameOutput.textContent = 'Anonymous';
//   }
// });
// ------------------------------------------------------------------------------------------------
// Напиши скрипт, який під час набору тексту в інпуті input#name - input(подія input)
// підставляє його поточне значення в span#name - output як ім’я для привітання.
// Обов’язково очищай значення в інпуті по краях від пробілів.Якщо інпут порожній або містить лише пробіли,
// то замість імені у спан має підставлятися рядок "Anonymous".

// <input type="text" id="name-input" placeholder="Please enter your name" />
// <h1>Hello, <span id="name-output">Anonymous</span>!</h1>

// На що буде звертати увагу ментор при перевірці:

// На елементі input#name-input прослуховується подія input
// Під час набору тексту в інпуті його поточне значення підставляється в span#name-output як ім’я для привітання
// Значення в інпуті очищене від пробілів по краях
// Якщо інпут порожній або містить лише пробіли, то замість імені у спан має підставлятися рядок "Anonymous"

// const nameInput = document.querySelector('name-input');
// const nameOutput = document.querySelector('name-output');

// nameInput.addEventListener('input', () => {
//   const name = nameInput.value.trim();

//   if (name) {
//     nameOutput.textContent = name;
//   } else {
//     nameOutput.textContent = 'Anonymous';
//   }
// });
// -------------------------------------------------------------------------------------------------------
// Напиши скрипт управління формою логіна.

// <form class="login-form">
//   <label>
//     Email
//     <input type="email" name="email" />
//   </label>
//   <label>
//     Password
//     <input type="password" name="password" />
//   </label>
//   <button type="submit">Log in</button>
// </form>

// відправлення форми form.login-form повинна відбуватися за подією submit.
// Під час відправлення форми сторінка не повинна перезавантажуватися.
// Якщо при сабміті у формі є незаповнені поля, виводь alert з попередженням про те,
// що 'All form fields must be filled in'.Не додавай на інпути атрибут required, валідація має відбуватися саме через JS.
// Якщо користувач заповнив усі поля і відправив форму, збери значення полів в об'єкт з двома властивостями,
// де ключ — це ім'я інпутів, а значення — відповідні значення цих інпутів, очищені від пробілів по краях.
// Для доступу до елементів форми використовуй властивість elements.
// При сабміті форми виведи об'єкт із введеними даними в консоль і очисти значення полів форми методом reset.

// На що буде звертати увагу ментор при перевірці:

// Прослуховується подія submit
// Під час відправлення форми сторінка не перезавантажується
// Якщо при сабміті у формі є незаповнені поля, виводиться alert
// При сабміті в консоль виводиться об’єкт з двома властивостями, де ключі — це ім’я інпутів,
// а значення — відповідні значення цих інпутів, очищені від пробілів по краях
// Після сабміту елементи форми очищаються
// Знаходимо форму за класом
// const loginForm = document.querySelector('.login-form');

// // Додаємо слухача події submit на форму
// loginForm.addEventListener('submit', (event) => {
//   // Скасовуємо перезавантаження сторінки при сабміті форми
//   event.preventDefault();

//   // Отримуємо доступ до елементів форми
//   const { email, password } = loginForm.elements;

//   // Очищаємо значення інпутів від пробілів по краях
//   const emailValue = email.value.trim();
//   const passwordValue = password.value.trim();

//   // Перевіряємо, чи заповнені поля
//   if (emailValue === '' || passwordValue === '') {
//     // Виводимо попередження, якщо поля не заповнені
//     alert('All form fields must be filled in');
//     return;
//   }

//   // Створюємо об'єкт з даними форми
//   const formData = {
//     email: emailValue,
//     password: passwordValue,
//   };

//   // Виводимо об'єкт у консоль
//   console.log(formData);

//   // Очищаємо форму після сабміту
//   loginForm.reset();
// });
// ----------------------------------------------------------------------------------------
// fНапиши скрипт, який змінює колір фону елемента < body > через інлайн - стиль
// по кліку на button.change - color і задає це значення кольору текстовим вмістом для span.color.
// <div class="widget">
//   <p>Background color: <span class="color">-</span></p>
//   <button type="button" class="change-color">Change color</button>
// </div>
// Для генерування випадкового кольору використовуй функцію getRandomHexColor().
// function getRandomHexColor() {
//   return `#${Math.floor(Math.random() * 16777215)
//     .toString(16)
//     .padStart(6, 0)}`;
// }
// Зверни увагу, що функція getRandomHexColor() повертає колір у hex - форматі, в той час як колір фону на < body >
//   буде у форматі rgb.Це нормально й не потребує якихось правок.

// На що буде звертати увагу ментор при перевірці:

// Фон на <body> задається тільки після кліку на button.change-color
// При кожному кліку на елемент button.change-color фон <body> зафарбовується новим рандомним кольором
// На < body > і span.color значення одного й того самого кольору

// function getRandomHexColor() {
//   return `#${Math.floor(Math.random() * 16777215)
//     .toString(16)
//     .padStart(6, 0)}`;
// }

// Знаходимо елементи button, span і body
// const changeColorButton = document.querySelector('.change-color');
// const colorSpan = document.querySelector('.color');
// const bodyElement = document.querySelector('body');

// Додаємо слухача події cli/ck на кнопку
// changeColorButton.addEventListener('click', () => {
// Генеруємо випадковий колір
//   const randomColor = getRandomHexColor();

// Задаємо новий колір ф/ону для body
//   bodyElement.style.backgroundColor = randomColor;

// Відображаємо значення кольору в спані
//   colorSpan.textContent = randomColor;
// });
// ------------------------------------------------------------------------------------------------
// Напиши скрипт створення й очищення колекції елементів з наступним функціоналом.
// Є input, у який користувач вводить бажану кількість елементів.Після натискання на кнопку
// Create має рендеритися(додаватися в DOM) колекція з відповідною кількістю елементів і очищатися значення в інпуті.
// При повторному натисканні на кнопку Create поверх старої колекції має рендеритись нова.
// Після натискання на кнопку Destroy колекція елементів має очищатися.

// <div id="controls">
//   <input type="number" min="1" max="100" step="1" />
//   <button type="button" data-create>Create</button>
//   <button type="button" data-destroy>Destroy</button>
// </div>

// <div id="boxes"></div>

// Після натискання користувачем на кнопку Create треба провалідувати значення в input, воно має бути в межах від 1 до 100 включно.
// Тільки якщо воно задоволяє умову, мають додаватися нові < div > елементи в DOM.

// Для рендеру елементів на сторінці створи функцію createBoxes(amount), яка приймає один параметр — число,
//   що зберігає кількість елементів для рендеру.

// Функція має створювати стільки < div > елементів, скільки вказано в параметрі amount.
// Усі ці < div > мають додаватися за одну операцію у DOM дочірніми елементами для div#boxes.

// Розміри першого <div> елемента мають бути 30px на 30px.
// Кожен наступний елемент повинен бути ширшим і вищим від попереднього на 10px.
// Усі елементи повинні мати випадковий колір фону. Використовуй готову функцію getRandomHexColor() для отримання випадкового кольору.

// function getRandomHexColor() {
//   return `#${Math.floor(Math.random() * 16777215)
//     .toString(16)
//     .padStart(6, 0)}`;
// }

// Для очищення колекції після натискання на кнопку Destroy створи функцію destroyBoxes(), яка очищає вміст div#boxes,
//   у такий спосіб видаляючи всі створені елементи.

// На що буде звертати увагу ментор при перевірці:

// Після кліку на кнопку Create, якщо в input значення поза межами діапазону 1-100, нічого не відбувається
// Після кліку на кнопку Create в div#boxes за одну операцію додається така кількість різнокольорових квадратів, яка вказана в input.
//  Значення input очищається
// Після повторного кліку на кнопку Create попередні квадрати повністю прибираються
//  і замість них додаються нові у кількості, що вказана в input.Значення input очищається
// Усі квадрати в div#boxes різнокольорові і мають фон випадкового кольору
// Перший квадрат у div#boxes має розміри 30px на 30px, а кожен наступний на 10px вищий і ширший від попереднього
// Після натискання на кнопку Destroy усі квадрати з div#boxes мають видалятися

// Функція для генерації випадкового кольору у форматі HEX
// function getRandomHexColor() {
//   return `#${Math.floor(Math.random() * 16777215)
//     .toString(16)
//     .padStart(6, 0)}`;
// }

// // Знаходимо необхідні елементи
// const controls = document.querySelector('#controls');
// const input = controls.querySelector('input');
// const createButton = controls.querySelector('[data-create]');
// const destroyButton = controls.querySelector('[data-destroy]');
// const boxes = document.querySelector('#boxes');

// // Додаємо слухача події click для кнопки Create
// createButton.addEventListener('click', () => {
//   const amount = Number(input.value.trim());

//   // Перевіряємо, чи кількість в межах від 1 до 100
//   if (amount >= 1 && amount <= 100) {
//     createBoxes(amount);
//   } else {
//     alert('Please enter a number between 1 and 100');
//   }

//   input.value = ''; // Очищаємо поле інпуту після кліку
// });

// // Функція для створення колекції div елементів
// function createBoxes(amount) {
//   destroyBoxes(); // Очищаємо попередні елементи перед створенням нових
//   const newBoxes = [];
//   let size = 30;

//   for (let i = 0; i < amount; i++) {
//     const box = document.createElement('div');
//     box.style.width = `${size}px`;
//     box.style.height = `${size}px`;
//     box.style.backgroundColor = getRandomHexColor();
//     box.style.margin = '5px';
//     newBoxes.push(box);
//     size += 10;
//   }

//   boxes.append(...newBoxes); // Додаємо всі елементи за одну операцію
// }

// // Додаємо слухача події click для кнопки Destroy
// destroyButton.addEventListener('click', destroyBoxes);

// // Функція для очищення контейнера з div елементами
// function destroyBoxes() {
//   boxes.innerHTML = ''; // Очищаємо вміст div#boxes
// }
// -----------------------------------------------------------------------------------
