// -------------------------------Делегування подій---------------------------
// -------------------------------Поширення подій---------------------------
//     Поширення подій(event propagation) — це термін, що описує життєвий цикл події, який має три етапи:

// Занурення (capture phase).
// Таргетинг (target phase).
// Спливання (bubble phase).

// На практиці найчастіше використовують тільки фазу спливання.

// Давайте розглянемо детальніше ці фази під час настання події.

// Capturing phase(занурення) — подія починається на window і тоне(проходить через усі елементи - предки)
// до найглибшого цільового елемента, на якому відбулася подія.На схемі подія — це клік, і capturing закінчується на елементі < button >.
// Target phase(таргетинг) — подія дійшла до цільового елемента.Цей етап містить тільки повідомлення елемента про те,
//     що на ньому відбулася дія.
// Bubbling phase (спливання) — кінцева фаза, подія спливає від найглибшого, цільового елемента, через усі елементи-предки до window.

// Поширення подій часто неправильно використовується як синонім стадії спливання, але це лише частина всього процесу.
//  Тому щоразу, коли відбувається подія, відбувається її поширення.
// -----------------------------------------------------------------------------
//                                           Спливання подій
// Зараз ми зосередимося на фазі спливанні події, адже часто розробник працює саме зі спливанням.
// Під час настання події обробники спочатку спрацьовують на найбільш вкладеному елементі.
//     Потім — на його батьківському елементі, потім — вище і так далі, вгору по ланцюжку вкладеності.
// Цей процес називається спливання(event bubbling), тому що події «спливають» від внутрішнього елемента вгору через
//  усіх предків до window, подібно до спливання бульбашки повітря у воді.

// Розглянемо приклад: є три вкладені теги <div> з обробниками кліка на кожному з них.

// <div id="parent">
//   Parent
//   <div id="child">
//     Child
//     <div id="descendant">Descendant</div>
//   </div>
// </div>

// Спливання гарантує, що клік по #descendant викличе обробник кліка в такому порядку:
// спочатку на самому #descendant,
// потім на елементі #child,
// далі на елементі #parent,
// і так далі, вгору по ланцюжку предків до window.

//     Отже, якщо в прикладі клікнути на #descendant, то послідовно виведуться сповіщення
// через console.log для descendant → child → parent.
// ------------------------------------------------------------------------------------------
//                                         Цільовий елемент
// Незалежно від місця, де ми спіймали слухачем подію під час її спливання, завжди можна дізнатися, де саме вона відбулася.
// Елемент, на якому відбулася подія, називається цільовим, або вихідним.Це завжди найглибший елемент,
// з якого починається спливання.Він доступний як event.target.

// event.target — це посилання на вихідний елемент, на якому відбулася подія, у процесі спливання вона — незмінна.
//     event.currentTarget — це посилання на поточний елемент, до якого прив’язаний поточний обробник події,
//         і до якого в результаті спливання дійшла прослуховувана подія.

// Якщо слухач події зареєстрований на найвищому елементі, то цей обробник зможе "перехопити" всі кліки,
//     які відбуваються на його дочірніх елементах, завдяки механізму спливання подій.
//     У прикладі нижче це працює таким чином: обробник зареєстрований на елементі "Parent".
//     Кліки на "Descendant" або "Child" будуть спливати до "Parent", де їх і буде оброблено цим обробником.
//     Тому важливо розуміти різницю між елементом, де подія фактично відбулася(event.target), та елементом, до якого подія спливла,
//     і обробник її перехопив(event.currentTarget).

// Відкрий консоль у прикладі і поклікай. Зверни увагу, що:

// event.target — це завжди вихідний (і найглибший) елемент, на якому був клік;
// event.currentTarget при цьому не змінюється.
// ---------------------------------------------------------------------------------------------
//                                    Припинення спливання
// Зазвичай подія буде спливати вгору до елемента window, викликаючи всі наявні обробники на своєму шляху.

// А інколи один елемент може мати кілька обробників на одну й ту саму подію.

// Уявімо, що сталася подія на елементі Descendant. Подія спливає до Child і Parent.

// Будь-який проміжний обробник може зупинити спливання цієї події за допомогою методів об’єкта події (event):

// event.stopPropagation(),
//     event.stopImmediatePropagation(),

// У чому ж різниця у використанні цих методів?

// event.stopPropagation()

// Зупиняє "спливання" події в DOM-дереві. Це означає, що жоден батьківський елемент не зможе відловити цю подію.
// Не заважає іншим обробникам подій виконуватися на тому ж самому елементі.

// event.stopImmediatePropagation()

// Зупиняє "спливання" події так само, як event.stopPropagation().
// Також зупиняє виконання всіх інших обробників подій, які слухають цю ж подію на даному елементі,
//     навіть якщо вони були зареєстровані перед цим.

// Не припиняйте спливання без необхідності.
//  Припинення спливання створює свої підводні камені, які потім доводиться обходити.Наприклад, вебаналітика використовує спливання,
//     щоб відстежувати дії користувача на сторінці, тому якщо зупинити спливання подій, то це унеможливить збір цієї інформації.
// -----------------------------------------------------------------------------
//                                           Делегування подій

// Спливання дозволяє реалізувати один із найкорисніших прийомів — делегування подій.

//     Уявімо, що є група елементів.Їх події потрібно обробляти однаково.Для цього треба додати обробник до кожного елемента.
//  Але це не зручно.

// Делегування подій (event delegation) полягає в додаванні одного обробника на спільного предка цих елементів.

// Розглянемо делегування на прикладі:

// створюємо елемент <div>,
// додаємо до нього будь-яку кількість кнопок, наприклад, 100,
// реєструємо на кожній кнопці слухача події кліку з обробником handleButtonClick.

// Проблема в тому, що в нас є 100 слухачів подій. Усі вони вказують на один і той самий обробник слухача, але слухачів 100.

// Завдяки тому, що події спливають, ми можемо відловити їх на спільному предку — елементі <div>.

// Тепер є тільки один слухач події кліку з обробником handleButtonClick і браузеру не потрібно зберігати в пам'яті 100 різних слухачів.

// Отже, делегування реалізується у три прості кроки.
// 1. Визначити спільного предка групи елементів для відстеження подій.
// 2. Зареєструвати на елементі-предку обробник події, яку ми хочемо відловлювати з групи елементів.
// 3. В обробнику використовувати event.target для вибору цільового елемента, на якому безпосередньо відбулась подія.

// У коді це матиме такий вигляд:

// const box = document.querySelector(".box");

// box.addEventListener("click", function (event) {
// 	console.log(event.target); // Елемент, на якому відбулась подія click
// });

// Такий підхід спрощує ініціалізацію слухачів однотипних елементів.Можна додавати, видаляти або змінювати елементи.
// При цьому не потрібно вручну додавати або видаляти обробники подій на кожному з них.

// Розбери код живого прикладу, в якому цільовий елемент кліка виводиться в консоль.

// Спробуй клікнути по кнопках, а також безпосередньо між ними, по div.box, і подивись результат.
// ------------------------------------------------------------------------------------------------
//                              Перевірка цільового елемента події

// Є задача створити палітру кольорів. Палітра дає можливість вибрати колір по кліку і відображає обраний колір.

// <p class="output">Selected color: -</p>
// <div class="color-palette"></div>

// Кожен клік на елементі палітри — це подія, яка змінює колір і вміст заголовка.
// Елементів дуже багато.Замість призначення обробника кожному елементу палітри,
//     повісимо один слухач на загального предка div.color - palette.

// const colorPalette = document.querySelector(".color-palette");

// colorPalette.addEventListener("click", selectColor);

// function selectColor(event) {
//  	console.log(event.target);
// 	const selectedColor = event.target.dataset.color;
// }

// В обробнику події кліка використовуємо event.target, щоб отримати елемент, на якому безпосередньо відбулася подія,
//     і пов'язаний з ним колір. Інформацію про колір будемо зберігати в атрибуті data-color.

// Обов'язково перевіряємо цільовий елемент події click.

// Це точно має бути кнопка, в іншому разі ми випадково можемо обробити клік, коли користувач клікне між кнопками,
//     що може викликати помилку.

// Для перевірки типу елемента використовуємо властивість nodeName.

// function selectColor(event) {
//   if (event.target.nodeName !== "BUTTON") {
//     return; // користувач клікнув між кнопками
//   }
//   const selectedColor = event.target.dataset.color; // користувач клікнув на кнопку і ми маємо доступ до її атрибутів
// }
// Розглянь повний живий приклад створення палітри кольорів.
// ---------------------------------------------------------------------------------
//                                                      Бібліотеки
// Бібліотеки — це набір попередньо написаних функцій, методів і класів, який надає розробнику готові
// інструменти для вирішення певних завдань.Бібліотеки створюються для полегшення розробки, оскільки дають змогу
//  використовувати готові рішення, необхідні для низки завдань, без потреби писати код з нуля.

// Основні характеристики бібліотек:
// Багаторазове використання: Бібліотеки створюються з метою повторного використання.
// Розробники можуть інтегрувати бібліотеки в різні проєкти й використовувати їхній функціонал без необхідності писати код з нуля.
// Перевизначений функціонал: Бібліотеки містять готовий код, який можна використовувати для розв'язання поширених завдань.
// Наприклад, бібліотеки можуть містити функції для роботи з датами, опрацювання рядків, виконання анімацій і багато чого іншого.
// Прискорення розробки: Використання бібліотек дає змогу скоротити час розробки, оскільки розробнику не потрібно створювати й
// налагоджувати функції або компоненти з нуля.Вони можуть застосовувати готові та перевірені рішення.
// Суспільство та підтримка: Хороші бібліотеки часто підтримуються активною спільнотою розробників, які вносять покращення,
//     виправлення помилок і забезпечують зворотну сумісність.

// Приклади популярних бібліотек у JavaScript:

// Chart.js: Бібліотека для створення інтерактивних графіків і діаграм.
// Lodash: Бібліотека для роботи з масивами, об'єктами, рядками тощо, що надає безліч зручних функцій.
// Важливо обирати бібліотеки, які найкраще підходять для вашого проєкту, і стежити за їхніми оновленнями,
//     щоб використовувати останні покращення та виправлення помилок.
// ----------------------------------------------------------------------------------------------
//                                         Підключення бібліотеки
// Для того щоб мати можливість використовувати бібліотеку в проєкті, її необхідно підключити, тобто додати файли бібліотеки до проєкту.
// Для прикладу підключимо до проєкту бібліотеку Lodash через CDN. Підключення JavaScript бібліотеки через CDN складається з декількох кроків.

// Крок 1. Для початку зайди на сайт CDN сервісу https://www.jsdelivr.com/ і знайди необхідну бібліотеку за її ім'ям.

// Крок 2. У списку результатів обери необхідну бібліотеку, клікнувши на назву.Після переходу за посиланням,
//     ти опинишся на сторінці з інформацією про бібліотеку.

//     Крок 3. Скопіюй HTML - код тега script, після чого відкрий свій HTML - файл і додай посилання на скрипт
// бібліотеки наприкінці HTML - документа, як показано в прикладі.

// <!DOCTYPE html>
// <html lang="en">
//   <head>
// 	 <!-- head tags -->
//   </head>
//   <body>
//     <!-- HTML-markup -->

//     <!-- Lodash library script file -->
// 		<script async src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
//     <!-- Your script file -->
//     <script defer src="path/to/script.js"></script>
//   </body>
// </html>

// Підключення скрипта бібліотеки має бути до підключення твого основного файлу скриптів.
// Не забудь додати тегу script бібліотеки атрибут async. Це потрібно для того, щоб файл бібліотеки завантажувався якомога швидше.

// Тепер ти можеш отримати доступ до бібліотеки у своєму скрипті.

// При підключенні бібліотек через CDN, до об'єкта window додається властивість, у якій зберігається те, що надає бібліотека.
//  Ім'я цієї властивості унікальне для бібліотеки та описане в її документації.

// Для Lodash — це символ нижнього підкреслення _.

// console.log(_); // Весь об'єкт бібліотеки Lodash

// Для перевірки використовуй методи:

// sum — він обчислює суму значень у масиві
// shuffle — створює масив перетасованих значень

// console.log(_.sum([4, 2, 8, 6])); // 20
// console.log(_.sum([5, 10])); // 15

// console.log(_.shuffle([1, 2, 3, 4])); // [4, 1, 3, 2]
// console.log(_.shuffle([1, 2, 3, 4])); // [3, 2, 1, 4]

// Зверни увагу! Спосіб підключення та використання бібліотек може відрізнятися залежно від конкретної бібліотеки.

// Усі сучасні бібліотеки надають документацію та приклади використання на своїх офіційних вебсайтах,
//     що може допомогти глибше розібратися в їхньому функціоналі.
// --------------------------------------------------------------------------------
