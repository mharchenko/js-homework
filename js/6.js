// Контекст виконання функції
// Ключове слово this

// Контекст функції у JavaScript подібний до контексту в реченні.
// Розглянемо наступні приклади для кращого розуміння:

// Віктор біжить швидко, тому що Віктор намагається зловити поїзд.
// Віктор біжить швидко, тому що він намагається зловити поїзд.

// Друге речення звучить більш лаконічно та природньо, чи не так?

//     Використання займенника "він" дозволяє уникнути повторення підмета "Віктор".
// Речення задає контекст, у якому Віктор — це об’єкт у центрі уваги, який виконує дії.
// Немає жодних сумнівів, що займенник "він" у рамках цього речення вказує саме на підмет
//  “Віктор”, отже, немає сенсу повторювати ім’я ще раз.

// Так само об'єкт може бути поточним контекстом під час виконання функції.

// Використання імені самого об'єкта для доступу до його властивостей усередині методів є поганим підходом.
// Це те ж саме, що й кожен раз повторювати "Віктор" замість "він" у реченні.

// const user = {
//   username: "Victor",
//   showName() {
// 		// ❌ Віктор біжить швидко, тому що Віктор намагається зловити поїзд
//     console.log(user.username);
//   },
// };

// user.showName();

// Замість імені об'єкта, ми використовуємо зарезервоване ключове слово this.

// Під час виклику функції у this записується посилання на об'єкт, у контексті якого вона була викликана.
//  Таким чином, у тілі функції ми можемо отримати доступ до властивостей і методів цього об'єкта.

// const user = {
//   username: "Victor",
//   showName() {
// 		// ✅ Віктор біжить швидко, тому що він (this) намагається зловити поїзд.
//     console.log(this.username);
//   },
// };

// user.showName();

// Метод showName — це функція, яка викликається в контексті об'єкта user.
//  Під час її виклику в this записується посилання на об'єкт user, і ми можемо звертатися до його властивостей і методів.
// -----------------------------------------------------------------
// Виконай рефакторинг методів об'єкта pizzaPalace, розставивши відсутні this в місцях звернення до властивостей і методів об'єкта.

// Метод checkPizza об'єкта pizzaPalace використовує this
// Метод order об'єкта pizzaPalace використовує this
// Виклик pizzaPalace.order("Smoked") повертає рядок "Order accepted, preparing «Smoked» pizza"
// Виклик pizzaPalace.order("Four meats") повертає рядок "Order accepted, preparing «Four meats» pizza"
// Виклик pizzaPalace.order("Big Mike") повертає рядок "Sorry, there is no pizza named «Big Mike»"
// Виклик pizzaPalace.order("Viennese") повертає рядок "Sorry, there is no pizza named «Viennese»"

// const pizzaPalace = {
//   pizzas: ['Supercheese', 'Smoked', 'Four meats'],
//   checkPizza(pizzaName) {
//     return pizzas.includes(pizzaName);
//   },
//   order(pizzaName) {
//     const isPizzaAvailable = checkPizza(pizzaName);

//     if (!isPizzaAvailable) {
//       return `Sorry, there is no pizza named «${pizzaName}»`;
//     }

//     return `Order accepted, preparing «${pizzaName}» pizza`;
//   },
// };

// const pizzaPalace = {
//   pizzas: ['Supercheese', 'Smoked', 'Four meats'],
//   checkPizza(pizzaName) {
//     return this.pizzas.includes(pizzaName);
//   },
//   order(pizzaName) {
//     const isPizzaAvailable = this.checkPizza(pizzaName);

//     if (!isPizzaAvailable) {
//       return `Sorry, there is no pizza named «${pizzaName}»`;
//     }

//     return `Order accepted, preparing «${pizzaName}» pizza`;
//   },
// };

// console.log(pizzaPalace.order('Smoked'));
// //   повертає рядок "Order accepted, preparing «Smoked» pizza"
// console.log(pizzaPalace.order('Four meats'));
// //   повертає рядок "Order accepted, preparing «Four meats» pizza"
// console.log(pizzaPalace.order('Big Mike'));
// //   повертає рядок "Sorry, there is no pizza named «Big Mike»"
// console.log(pizzaPalace.order('Viennese'));
// //   повертає рядок "Sorry, there is no pizza named «Viennese»"
// -------------------------------------------------------------------
// Глобальний контекст

// У визначенні значення this є важливий нюанс.Значення this визначається не на момент оголошення функції
//     (за винятком стрілкових функцій), а на момент її виклику.Іншими словами, this визначається тим,
// як саме функцію викликали, а не де вона була оголошена.

// function foo() {
//   console.log(this);
// }
// foo(); // window

// У глобальному контексті, якщо функція виконується не в суворому режимі, this посилається на об'єкт window.
//  Об'єкт window надає доступ до браузерних властивостей і функцій та є глобальним контекстом виконання для скриптів у браузері.

// У суворому режимі значення this у глобальному контексті завжди буде undefined.

// "use strict";

// function foo() {
//   console.log(this);
// }
// foo(); // undefined
// -------------------------------------------------------------------------------------
// Контекст методу об'єкта

// Якщо функція була викликана як метод об'єкта, то контекст вказуватиме на сам об'єкт, якому належить цей метод.

// const user = {
//   username: 'Poly',
//   showThis() {
//     console.log(this);
//   },
// };

// user.showThis(); // {username: "Poly", showThis: ƒ}

// Розглянемо складніший приклад.

// Спочатку створюємо функцію в глобальному контексті і викликаємо її. Зверни увагу на використання суворого режиму.

// ('use strict');

// function showThis() {
//   console.log('this in showThis: ', this);
// }

// Викликаємо у глобальному контексті
// showThis(); // "this in showThis: undefined"

// Потім присвоюємо цю функцію властивості об'єкта і викликаємо її як метод цього об'єкта.

// ('use strict');

// function showThis() {
//   console.log('this in showThis: ', this);
// }

// const user = {
//   username: 'Poly',
// };

// user.showContext = showThis;

// Викликаємо в контексті об'єкта
// user.showContext(); // this in showThis: {username: "Poly", showContext: ƒ}

// Викликаємо в глобальному контексті
// showThis(); // "this in showThis: undefined"

// Створили об'єкт user з властивістю username
// Об'єкту user методу showContext присвоїли значення функції showThis. Зверни увагу, що це не виклик — немає ()
// Тепер викликаємо метод showContext, у якому знаходиться посилання на функцію showThis,
//     тобто ми викликаємо функцію в контексті об'єкта. this вказуватиме на поточний об'єкт, у якому здійснюється виклик

// Цей приклад ілюструє, що контекст виконання функції (this) визначається в момент її виклику, а не в момент оголошення.
// -------------------------------------------------------------------------
// Метод call()

// Бувають ситуації, коли функцію потрібно викликати в контексті об'єкта, навіть якщо функція не є методом цього об'єкта.
//  Для цього у JavaScript існують спеціальні методи: call, apply і bind, які дозволяють вказати контекст виклику функції.

// Вивчимо сигнатуру цього методу. Сигнатура — це ім'я методу і його параметри.

// Сигнатура методу call**()** виглядає так:

// foo.call(thisArg, arg1, arg2, ...)

// thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції
// arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції

// Метод call викликає функцію foo так, що значення this у функції буде посилатися на об'єкт thisArg,
//  і також передає їй аргументи arg1, arg2 тощо.

// Розглянемо приклад: давай створимо функцію greet, яка вітає різних користувачів готелю, кожен з яких
//  представлений об'єктом з властивостями username і room. Функція приймає один параметр, str — рядок привітання.

// function greet(str) {
//   console.log(`${str}, ${this.username}, your room is ${this.room}!`);
// }

// const mango = {
//   username: 'Mango',
//   room: 27,
// };

// const poly = {
//   username: 'Poly',
//   room: 191,
// };

// // За допомогою методу call ми можемо викликати функцію greet так, щоб значення this вказувало на
// //  потрібний об'єкт і використовувало значення його властивостей.

// greet.call(mango, 'Hi'); // "Welcome, Mango, your room is 27!"
// greet.call(poly, 'Aloha'); // "Aloha, Poly, your room is 191!"
// // ----------------------------------------------------------------------------------------------------
// Метод apply()

// Метод apply є аналогом методу call.Відмінність у тому, що в методі apply()
//  синтаксис передачі аргументів вимагає масиву, навіть якщо аргументи функції — це окремі значення.

// Сигнатура методу apply**()** виглядає так:

// foo.apply(thisArg, [arg1, arg2, ...])

// thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції.
// arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції.

// Метод apply викликає функцію foo таким чином, що значення this у функції буде
// посилатися на об'єкт obj і передасть елементи масиву як окремі аргументи arg1, arg2 тощо.

// Розгляньмо приклад, де використаємо раніше оголошену нами функцію greet.Цього разу викликаємо її,
//     використовуючи метод apply замість call.

// function greet(str) {
//   console.log(`${str}, ${this.username}, your room is ${this.room}!`);
// }

// const mango = {
//   username: "Mango",
// 	room: 27
// };

// const poly = {
//   username: "Poly",
// 	room: 191
// };

// greet.apply(mango, ["Welcome"]); // "Welcome, Mango, your room is 27!"
// greet.apply(poly, ["Aloha"]); // "Aloha, Poly, your room is 191!"

// Тобто різниця між call і apply полягає лише у формі передачі аргументів.
// Вибір між call і apply залежить від того, як саме ти хочеш передавати аргументи до функції в конкретній ситуації.
// У всіх інших аспектах вони працюють
// ідентично: викликають функцію в контексті зазначеного об'єкта і передають їй аргументи.
// -----------------------------------------------------------------------------------------
// Метод bind() і втрата контексту

// Методи call і apply викликають функцію «на місці», тобто одразу.

// Метод bind створює і повертає нову функцію, яка має заздалегідь встановлений контекст,
// і ця нова функція може бути викликана пізніше з будь - якими аргументами.

// Сигнатура методу bind() виглядає так:

// const boundFoo = foo.bind(thisArg, arg1, arg2, ...)

// thisArg — об'єкт, який ми хочемо встановити як контекст (значення this) для функції
// arg1, arg2, ... — необов'язкові аргументи, які будуть передані функції при її виклику

// Давай спробуємо зберегти посилання на метод об'єкта у змінну і викликати його в глобальному контексті.

// 'use strict';

// const customer = {
//   username: 'Jacob',
//   sayHello() {
//     console.log(`Hello, ${this.username}!`);
//   },
// };

// customer.sayHello(); // "Hello, Jacob!"

// const greet = customer.sayHello;

// greet(); // TypeError: Cannot read properties of undefined (reading 'username')

// Зберегли посилання на метод sayHello у змінну greet
// При виклику greet() контекст втрачено, функція викликається в глобальному контексті, тому значення this буде undefined
// При спробі звернутися до властивості this.username під час виклику функції greet(),
//     виникає помилка, оскільки undefined — це навіть не об'єкт
// Це можна виправити, прив'язавши контекст за допомогою методу bind.

// ('use strict');

// const customer = {
//   username: 'Jacob',
//   sayHello() {
//     console.log(`Hello, ${this.username}!`);
//   },
// };

// customer.sayHello(); // "Hello, Jacob!"

// const greet = customer.sayHello.bind(customer);

// greet(); // "Hello, Jacob!"

// Коли ми використовуємо bind(), ми створюємо нову функцію greet.Ця нова функція завжди матиме
// правильний контекст і може використовувати властивість username об'єкта customer.
// ----------------------------------------------------------------------------------------------
// Метод bind() і колбеки

// Метод bind() є дуже корисним.Особливо важливо його використовувати в колбек - функціях і ситуаціях,
//     де можлива втрата контексту під час виклику функції.
// Розглянемо приклад втрати контексту, коли ми передаємо метод об'єкта як колбек-функцію:

// "use strict";

// const customer = {
//   firstName: "Jacob",
//   lastName: "Mercer",
//   getFullName() {
//     return `${this.firstName} ${this.lastName}`;
//   }
// };

// function makeMessage(callback) {
//   // callback() — це виклик методу getFullName в глобальному контексті
// 	const username = callback();
//   console.log(`Processing an application from ${username}`);
// }
// makeMessage(customer.getFullName); // TypeError: Cannot read properties of undefined (reading 'firstName')

// У цьому випадку метод getFullName передається як колбек - функція callback і втрачає контекст об'єкта customer.
//  Це призводить до помилки, оскільки значення this у методі getFullName,
//     коли він викликається як колбек у глобальному контексті, є undefined.Звертаючись до властивостей firstName і lastName,
//         ми отримаємо помилку, оскільки undefined — це не об'єкт.

// Щоб уникнути цієї втрати контексту, можна використати метод bind().
//  Замість передачі оригінального методу getFullName, ми передаємо його копію, до якої прив'язаний контекст об'єкта customer.

// const customer = {
//   firstName: 'Jacob',
//   lastName: 'Mercer',
//   getFullName() {
//     return `${this.firstName} ${this.lastName}`;
//   },
// };

// function makeMessage(callback) {
//   const username = callback();
//   console.log(`Processing an application from ${username}`);
// }

// makeMessage(customer.getFullName.bind(customer)); // "Processing an application from Jacob Mercer"
// -----------------------------------------------------------------------------------
// Стрілочні функції

// Контекст усередині стрілочної функції визначається місцем її оголошення, а не виклику.

// Це означає, що this усередині стрілки посилається на контекст батьківської області видимості,
//     в якій вона була оголошена, і ніколи не змінюється.

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// showThis(); // this in showThis: window

// Навіть якщо присвоїти посилання на стрілочну функцію у властивість об'єкта
//  і викликати її в контексті цього об'єкта, this усе одно буде посилатися на
//   об'єкт, який функція запам'ятала в момент її оголошення.

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// const user = {
//   username: "Mango",
// };

// user.showContext = showThis;

// user.showContext(); // this in showThis: window

// Стрілочні функції також ігнорують наявність суворого режиму.

// Якщо стрілка була оголошена в глобальному контексті, то this у ній буде містити посилання
//  на window, незалежно від того, чи виконується скрипт у суворому режимі.

// "use strict";

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// showThis(); // this in showThis: window

// Розгляньмо приклад, який добре ілюструє, як працює контекст для стрілочних функцій.

// const hotel = {
//   username: "Resort hotel",
//   showThis() {
//     const foo = () => {
//       console.log("this in foo: ", this);
//     };

//     foo();
//     console.log("this in showThis: ", this);
//   },
// };

// hotel.showThis();
// // this in foo: {username: 'Resort hotel', showThis: ƒ}
// // this in showThis: {username: 'Resort hotel',showThis: ƒ}

// Під час виклику методу hotel.showThis() стрілочна функція foo() викликається
//  в глобальному контексті без об'єкта, але значення this усередині неї посилається
//   на контекст методу showThis, тобто об'єкт hotel.Це тому, що вона була оголошена
//    всередині методу showThis, і в момент її оголошення this запам'ятовує посилання
//    на батьківський контекст.Інакше кажучи, стрілки запам'ятовують контекст під час
//    оголошення з батьківської області видимості.

// Можливо, це не часто використовується на практиці. Але такі кейси досить типові для співбесіди.

// На відміну від звичайних функцій, змінити значення this усередині стрілки після її
// оголошення неможливо.Це означає, що методи call, apply і bind не впливають на значення this у стрілках.

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// showThis.call({ username: "Mango" }); // this in showThis: window
// showThis.apply({ username: "Mango" }); // this in showThis: window

// const boundShowThis = showThis.bind({ username: "Mango" });
// boundShowThis(); // this in showThis: window

// Обмежуючи стрілочні функції постійним контекстом, JavaScript - рушії можуть краще їх оптимізувати,
//     на відміну від звичайних функцій, значення this яких може бути змінено.

// Що треба запам’ятати про this у стрілочних функціях?

// 1.Контекст **this** усередині стрілочної функції визначається місцем її оголошення, а не виклику.
// 2.Стрілочні функції ігнорують наявність суворого режиму.Тому в глобальному контексті у стрілці
// завжди this посилається на об'єкт window.
// 3.Неможливо змінити значення this усередині стрілочних функцій після її оголошення.Методи call,
//     apply і bind не впливають на значення this у стрілках.
// --------------------------------------------------------------
// Алгоритм визначення this
// Ключове слово this — це одна з найзаплутаніших концепцій для новачка.
// Новачки часто підставляють this методом наукового тику доти, доки скрипт не спрацює.
// Але все стає значно простішим, коли є простий алгоритм визначення значення this.

// Крок 1
// Це стрілочна функція?

// Якщо відповідь Так, значення this те саме, що у this у зовнішній області видимості
// Якщо відповідь Ні, переходь на Крок 2

// Крок 2
// Чи використовуються методи call, apply або bind?

// Якщо відповідь Так, значення this — це той самий об’єкт, що передали при їх виклику
// Якщо відповідь Ні, переходь на Крок 3

// Крок 3
// Функція викликається як метод об’єкта object.method?

// Якщо відповідь Так, значення this — це об’єкт ліворуч від крапки
// Якщо відповідь Ні, переходь на Крок 4

// Крок 4
// Скрипт виконується в суворому режимі?

// Якщо відповідь Так, значення this — undefined
// Якщо відповідь Ні, значення this — window

// Збережи собі цю схему, щоб швидко згадати алгоритм визначення this
// ----------------------------------------------------------------------
// Прототипи
// Прототип об'єкта
// Звідки беруться вбудовані методи масивів push, map, reduce та інші?
// Чому у функції є методи call і bind?
// Досі ми просто приймали, що вони є і ними можна користуватися. Прийшов час знайти відповіді на ці питання.
// Усе це можливо завдяки механізму прототипного успадкування, який дає змогу організувати
//  об'єкти в ланцюжки таким чином, щоб здійснювався автоматичний пошук властивості в іншому об'єкті, якщо її не знайдено в поточному.

// Схематично це виглядає так:
// //
// Сполучною ланкою виступає спеціальна службова властивість[[Prototype]], яку ми не змінюємо явно,
//     вона використовується для автоматичного зв'язку об'єктів.

// Метод Object.create(obj) створює і повертає новий об'єкт, зв'язуючи його з об'єктом obj. Розгляньмо приклад:

// const animal = {
//   legs: 4,
// };

// const dog = Object.create(animal);
// dog.name = "Mango";

// console.log(dog); // { name: "Mango", [[Prototype]]: animal }

// Об'єкт, на який вказує посилання у властивості [[Prototype]], називається прототипом.
//  У нашому прикладі об'єкт animal — це прототип для об'єкта dog.

// console.log(dog.name); // "Mango"
// console.log(dog.legs); // 4
// Звернення dog.name працює очевидним чином: повертає властивість name об'єкта dog.
//  Звертаючись до dog.legs, інтерпретатор шукає властивість legs в об'єкті dog, не знаходить
//   і продовжує пошук в об'єкті за посиланням з[[Prototype]], тобто в цьому випадку в об'єкті animal — його прототипі.
// Отже, прототип — це резервне сховище властивостей і методів об'єкта, яке автоматично використовується під час їх пошуку.
// -------------------------------------------------------------------------------------
// Зміни код таким чином, щоб об'єкт parent став прототипом для об'єкта у змінній сhild.

// Оголошена змінна parent
// Значення змінної parent - це об'єкт
// Оголошена змінна child
// Значення змінної child - це об'єкт
// Використовується метод Object.create()

// const parent = {
//   name: "Stacey",
//   surname: "Moore",
//   age: 54,
//   heritage: "Irish",
// };

// const child = {};
// child.name = "Jason";
// child.age = 27;

// const parent = {
//   name: 'Stacey',
//   surname: 'Moore',
//   age: 54,
//   heritage: 'Irish',
// };

// const child = Object.create(parent);
// child.name = 'Jason';
// child.age = 27;

// console.log(parent.hasOwnProperty('surname'));
//  повертає true
// console.log(parent.hasOwnProperty('heritage'));
//  повертає true
// console.log(child.hasOwnProperty('name'));
//  повертає true
// Звернення до child.name повертає "Jason"
// -----------------------------------------------------------------------------
// Перевірка прототипу

// Якщо в коді потрібно перевірити, чи є об'єкт прототипом іншого об'єкта, використовується метод isPrototypeOf().

// objA.isPrototypeOf(objB)
// Метод перевіряє, чи є об'єкт objA прототипом для об’єкта objB
// Якщо так, повертає true, в іншому разі повертає false

// Розгляньмо приклад використання методу isPrototypeOf() для перевірки належності прототипу.

// const customer = {
// 	username: "Jacob"
// };

// const animal = {
// 	legs: 4
// };

// const dog = Object.create(animal);
// dog.name = "Mango";

// console.log(dog); // { name: "Mango", [[Prototype]]: animal }

// console.log(animal.isPrototypeOf(dog)); // true
// console.log(dog.isPrototypeOf(animal)); // false
// console.log(customer.isPrototypeOf(dog)); // false
// у першому лозі виводиться об'єкт dog із властивістями name і [[Prototype]]. [[Prototype]] вказує на animal як прототип
// у другому — повертається true, оскільки animal є прототипом для dog
// у третьому — повертається false, оскільки прототип не успадковується у зворотному напрямку (від dog до animal)
// у четвертому лозі повертається false, оскільки customer не є прототипом для
// ----------------------------------------------------------------------------------
// Власні і невласні властивості

// Використаємо вже знайомий нам приклад створення об'єкта dog з прототипом animal.

// const animal = {
//   legs: 4,
// };
// const dog = Object.create(animal);
// dog.name = 'Mango';

// console.log(dog); // {name: "Mango", [[Prototype]]: animal}
// console.log(dog.name); // "Mango"
// console.log(dog.legs); // 4

// Властивість name належить об'єкту dog, тому називається власною властивістю об'єкта dog.
// Властивість legs не належить об'єкту dog. Це властивість його прототипу animal,
// тому вона називається невласною властивістю об'єкта dog.

// Для того щоб перевірити, чи є в об'єкті власна властивість, використовується метод obj.hasOwnProperty(key).
// Цей метод перевіряє наявність власної властивості з ім'ям key і повертає true, якщо є, і false в іншому випадку.

// console.log(dog.hasOwnProperty('name')); // true
// console.log(dog.hasOwnProperty('legs')); // false
// ---------------------------------------------------------------------------
// Перебір власних властивостей

// Оператор in, який використовується в циклі for...in, не розрізняє власні властивості об'єкта і його прототипу.
//  Ця особливість заважає, оскільки зазвичай потрібно перебрати тільки власні властивості.

// const animal = { legs: 4 };
// const dog = Object.create(animal);
// dog.name = "Mango";

// for (const key in dog) {
//   console.log(key); // "name" "legs"
// }

// Для вибору саме власних властивостей під час перебору циклом for...in необхідно на кожній
//  ітерації додати перевірку на власну властивість методом obj.hasOwnProperty(key).Цей метод повертає true,
//     якщо властивість з іменем key належить об'єкту obj, а не його прототипу, в іншому разі — false. Розгляньмо приклад:

// const animal = { legs: 4 };
// const dog = Object.create(animal);
// dog.name = "Mango";

// for (const key in dog) {
// 	if(dog.hasOwnProperty(key)) {
// 		console.log(key); // "name"
// 	}
// }

// Якщо це власна властивість — виконуємо тіло if
// Якщо це невласна властивість — нічого не робимо

// Методи Object.keys(obj) і Object.values(obj) повертають масив тільки власних ключів або
// значень тільки власних властивостей об'єкта obj, без необхідності додаткових перевірок.
// Через це на практиці використовують саме їх із циклом for...of, замість for...in і hasOwnProperty.

// const animal = { legs: 4 };
// const dog = Object.create(animal);
// dog.name = "Mango";

// console.log(Object.keys(dog)); // ["name"]
// console.log(Object.values(dog)); // ["Mango"]

// for(const key of Object.keys(dog)) {
// 	console.log(key); // "name"
// }
// -------------------------------------------------------------------------------
// Ланцюжки прототипів

// Об'єкт, який виступає прототипом для іншого об'єкта, також може мати свій прототип. Отже, існують ланцюжки прототипів.
// Давайте реалізуємо це в коді. Ланцюжок прототипів будується з кінця, тобто справа наліво.

// const objC = { c: 'objC prop' };

// const objB = Object.create(objC);
// objB.b = 'objB prop';

// const objA = Object.create(objB);
// objA.a = 'objA prop';

// console.log(objA); // { a: "objA prop", [[Prototype]]: objB }
// console.log(objB); // { b: "objB prop", [[Prototype]]: objC }
// console.log(objC); // { c: "objC prop", [[Prototype]]: Object }

// Створюємо об'єкт objC.
// Потім створюємо об'єкт objB і встановлюємо objC як його прототип.
// Після цього створюємо об'єкт objA і встановлюємо objB як його прототип.

// Максимально наочно буде:
// Вивести об'єкт objA у консоль розробника.
// Розгорнути властивості.
// Подивитися на структуру.
// Ця структура точно повторює ланцюжок прототипів.

// На що вказує властивість [[Prototype]] об'єкта objC, ми розглянемо трохи пізніше. Це окрема тема, якій варто приділити увагу.
// Оскільки об’єкти objA, objB і objC пов'язані в ланцюжок прототипів, об'єкт objA може отримати доступ до властивостей objB і objC,
//     а об'єкт objB — до властивостей objC.

// console.log(objA.hasOwnProperty('a')); // true
// console.log(objA.a); // "objA prop"

// console.log(objA.hasOwnProperty('b')); // false
// console.log(objA.b); // "objB prop"

// console.log(objA.hasOwnProperty('c')); // false
// console.log(objA.c); // "objC prop"

// console.log(objA.hasOwnProperty('x')); // false
// console.log(objA.x); // undefined

// Пошук властивостей відбувається до першого збігу. Інтерпретатор шукає властивість за ім'ям в об'єкті:
// Якщо інтерпретатор не знаходить власну властивість, то звертається до властивості[[Prototype]],
//     тобто переходить за посиланням до об'єкта-прототипу, а потім — до прототипу прототипу за ланцюжком.
// Якщо інтерпретатор доходить до кінця ланцюжка і не знаходить властивості з таким ім'ям, то повертається undefined.
// ------------------------------------------------------------------------------
// Зміни код, побудувавши ланцюжок прототипів таким чином, щоб об'єкт ancestor був прототипом для parent,
// а той, своєю чергою, був прототипом для child.

// Оголошена змінна ancestor
// Значення змінної ancestor - це об'єкт.
// Оголошена змінна parent
// Значення змінної parent - це об'єкт.
// Оголошена змінна child
// Значення змінної child - це об'єкт.

// /const ancestor = {
//   name: "Paul",
//   age: 83,
//   surname: "Dawson",
//   heritage: "Irish",
// };

// const parent = {};
// parent.name = "Stacey";
// parent.surname = "Moore";
// parent.age = 54;

// const child = {};
// child.name = "Jason";
// child.age = 27;

// const ancestor = {
//   name: 'Paul',
//   age: 83,
//   surname: 'Dawson',
//   heritage: 'Irish',
// };

// const parent = Object.create(ancestor);
// parent.name = 'Stacey';
// parent.surname = 'Moore';
// parent.age = 54;

// const child = Object.create(parent);
// child.name = 'Jason';
// child.age = 27;

// console.log(ancestor.isPrototypeOf('parent'));
// //  повертає false
// console.log(parent.isPrototypeOf('child'));
// //  повертає false
// console.log(ancestor.hasOwnProperty('surname'));
// //  повертає true
// // Звернення до ancestor.surname повертає "Dawconsole parent.hasOwnProperty("surname") повертає true
// // Звернення до parent.surname повертає "Moore"
// console.log(child.hasOwnProperty('surname'));
// //  повертає false
// // Звернення до child.surname повертає "Moore"
// console.log(ancestor.hasOwnProperty('heritage'));
// //  повертає true
// // Звернення до ancestor.heritage повертає "Irish"
// console.log(parent.hasOwnProperty('heritage'));
// //  повертає false
// // Звернення до parent.heritage повертає "Irish"
// console.log(child.hasOwnProperty('heritage'));
// //  повертає false
// // Звернення до child.heritage повертає "Irish"
// // Використовується метод Object.create()
// -------------------------------------------------------------
// Кінець ланцюжка прототипів
// Давай створимо ланцюжок прототипів із двох об'єктів.

// const objB = {
//   b: 'objB prop',
// };

// const objA = Object.create(objB);
// objA.a = 'objA prop';

// console.log(objA);
// Отже, objB — це прототип для об'єкта objA. Розгорнувши вміст ланцюжка
// прототипів у консолі розробника, ми побачимо таку картину.
// Ти вже знаєш, що у властивості[[Prototype]] об'єкта objA лежить посилання на об'єкт objB.
//  А що знаходиться у властивості[[Prototype]] об'єкта objB?
// Наприкінці ланцюжка прототипів завжди знаходиться посилання на базовий клас, від якого походить тип даних у ланцюжку.
// У нашому випадку objB — це об'єкт, тому в кінці ланцюжка буде посилання на клас Object.
// --------------------------------------------------------------------------

// ООП
// У чому різниця між хорошим і поганим кодом?

//     Досі головним критерієм було: хороший код працює без помилок, а поганий — ні.
// Але на практиці все складніше.Сучасний продукт рідко має кодову базу, меншу за 100 000 рядків.Те, що він працює — це добре,
//     але недостатньо.

// Важливі також такі критерії:

// Надійність — навіть дуже об'ємне і складне ПЗ має працювати стабільно.
// Масштабованість — можливість легко адаптувати ПЗ до зростаючого навантаження.
// Адаптивність — продукт має бути гнучким, щоб швидко міняти функціонал/інтерфейс.
// Вартість — зниження витрат на розробку і збільшення ефективності важливі для успішної конкуренції на ринку.

// Для створення коду, який задовольнятиме ці вимоги, потрібен або величезний практичний досвід(що не завжди можливо),
//     або знання принципів створення правильного коду.Отже, розгляньмо основні парадигми програмування та порівняємо їхні сильні та слабкі сторони.

// Процедурне програмування
// Процедурне програмування — це парадигма програмування, у якій програми структуровані у вигляді набору функцій,
//     які виконують певні дії над даними.

// Основні концепції процедурного програмування включають:

// Процедури(функції): Основною одиницею програми є функції.Вони призначені для виконання конкретних завдань.
// Функції приймають аргументи(вхідні дані), обробляють їх і можуть повертати результат(вихідні дані).
// Локальні та глобальні змінні: Змінні, що оголошуються в межах функції, є локальними й доступними лише в цій функції.
//     Змінні, оголошені поза функціями, є глобальними й доступними в усій програмі.

// Процедурний код — це набір не пов'язаних явно функцій і змінних для зберігання й обробки інформації.

// Цей підхід — простий і прямолінійний.Він може використовуватись для задач, в яких немає тісно пов'язаних сутностей
//     (даних і функцій для їх обробки).

// Розгляньмо приклад процедурного коду, в якому є глобальні змінні і функція для підрахунку результату.

// const baseSalary = 30000;
// const overtime = 10;
// const rate = 20;

// const getWage = (baseSalary, overtime, rate) => {
//   return baseSalary + overtime * rate;
// };

// getWage(baseSalary, overtime, rate);

// Процедурне програмування — це те, як ми з тобою писали код до сих пір.Воно є простим і зрозумілим і може бути
//  використане для написання простих програм.Проте зі збільшенням складності програми процедурний підхід може стати неефективним,
//     оскільки втрачається зв'язок між даними й методами їх обробки.
// ------------------------------------------------------------------------------------
// Об'єктно-орієнтоване програмування

// Об'єктно-орієнтоване програмування (ООП) — це парадигма програмування, в якій програми структуровані як сукупність об'єктів.
//  Ці об’єкти представляють реальні або абстрактні сутності: користувач, магазин, автомобіль тощо.
//  Кожен з об’єктів містить дані(властивості) і методи для взаємодії з ними.

// Перепишемо код із попереднього прикладу із застосуванням ООП.

// Для цього об'єднаємо дані та функцію їх обробки в об'єкт employee.

// const employee = {
//   baseSalary: 30000,
//   overtime: 10,
//   rate: 20,
//   getWage() {
//     return this.baseSalary + this.overtime * this.rate;
//   },
// };

// employee.getWage();

// При такому підході відсутні або майже відсутні глобальні змінні.Методи не залежать від параметрів,
//     а використовують властивості об'єкта, які задаються при його створенні і можуть бути змінені іншими методами.

// Програмування в стилі ООП допомагає структурувати код, полегшує його розробку та підтримку і дозволяє створювати
//  більш складні програми, організовані навколо об'єктів та їх взаємодії.
// ----------------------------------------------------------------------------------
// Клас
// Для розуміння основних концепцій об'єктно-орієнтованого програмування важливо володіти основними термінами.
//  Найпростіше буде розібрати їх через проведення аналогії з чимось із реального світу.

// Уявімо, що ми проєктуємо автомобіль. Про що варто подумати заздалегідь?
//     У нього буде двигун, чотири колеса, бензобак та інші запчастини.Автомобіль повинен виконувати певні дії: заводитися,
//     збільшувати і зменшувати швидкість тощо.Ми також маємо знати, як працює двигун і колеса, тобто за якими законами
//         взаємодіють різні частини машини.

// У проєкті треба описати:
// всі запчастини, з яких складається автомобіль
// яким чином ці запчастини взаємодіють між собою
// що повинен зробити водій, щоб автомобіль загальмував, увімкнулися фари тощо.

// Результатом нашої роботи буде один певний ескіз(шаблон, схема, кліше), на основі якого в подальшому буде створюватися
// необмежена кількість автомобілів.Ми тільки що розробили те, що в ООП називається класом.

//     Клас — це спосіб опису сутності, що визначає структуру та поведінку об'єктів, а також правила для взаємодії з
//     цією сутністю(контракт).Вони виступають в якості шаблонів для створення нових об'єктів.

// У нашому прикладі клас визначає сутність: автомобіль.
// Властивостями класу будуть запчастини: двигун, колеса, фари тощо.
// Методами класу будуть дії: відчинити двері, завести двигун, збільшити швидкість тощо.
// ----------------------------------------------------------------------------------------------
// Екземпляр класу

// У прикладі з попереднього розділу ми зупинилися на створенні певного ескізу(шаблону, схеми).
//     Автомобілі, розроблені за цими ескізами, сходять з конвеєра.Кожен з них точно повторює креслення:
//     усі системи взаємодіють саме так, як було спроєктовано.При цьому кожен автомобіль унікальний.
//     Усі автомобілі мають номер кузова і двигуна, але їхні номери різні.Автомобілі також розрізняються за кольором, оздобленням салону.

// Ці автомобілі — це екземпляри класу.

//     Екземпляр(об'єкт, інстанція) — це окремий представник класу, який має дані (властивості) і методи (функції),
//      які працюють з цими даними.Екземпляр — це те, що створено за кресленням, тобто на підставі опису з класу.

// Іншими словами, об'єкт має конкретні значення властивостей і методи, що працюють з цими властивостями на основі правил,
//  заданих у класі.У прикладі з автомобілями:

// Клас — це якийсь абстрактний автомобіль на кресленні
// Екземпляр (об'єкт) — це конкретний автомобіль, що стоїть у нас під вікнами
// --------------------------------------------------------------------------------------------
// Інтерфейс класу

// Сідаючи за кермо автомобіля, ми бачимо певний набір елементів управління, з якими можна взаємодіяти.
// Інтерфейс — це набір властивостей і методів класу, доступних для використання у роботі з екземпляром.
// По суті, інтерфейс описує клас, чітко визначаючи всі можливі дії над ним.
// Гарний приклад інтерфейсу — панель приладів автомобіля, яка дозволяє викликати методи, наприклад,
//     збільшення швидкості, гальмування, повороти, перемикання передач, увімкнення фар тощо.
// Описуючи інтерфейс класу, дуже важливо витримати баланс між гнучкістю й простотою.
// Клас із простим інтерфейсом легко використовувати, але будуть існувати завдання, які за допомогою нього буде складно вирішити.
// Якщо інтерфейс буде гнучким, то, найімовірніше, він буде містити досить складні методи з великою кількістю параметрів.
// Такий інтерфейс дозволить виконувати дуже багато дій,
//     але його використання буде пов'язане з труднощами й ризиком помилитися, переплутавши щось.
// --------------------------------------------------------------------------------------------------
// Класи
// Оголошення класу

// Синтаксис літерала об'єкта дозволяє створити один об'єкт.
// Проте часто є потреба створити багато однотипних об'єктів з однаковим набором властивостей,
//  але різними значеннями й методами для взаємодії з ними.Все це потрібно робити динамічно, під час виконання програми.
//  З цією метою використовують класи.

// Оголошення класу має такий синтаксис:

// ключове слово class
// ім’я класу (у прикладі: User)
// тіло класу у фігурних дужках

// class User {
//   // Тіло класу
// }

// Класи прийнято називати з великої літери, а в назві відображати тип об'єкта (іменника), що створюється.

// А як створити з класу екземпляр?

//     Після того як клас було оголошено, можна створити його екземпляр за допомогою спеціального оператора new,
//     поставивши його перед викликом класу.Результатом виклику new User() буде екземпляр класу User.
//         Він буде містити дані і мати поведінку, що описані у класі.

// class User {
//   // Тіло класу
// }

// const mango = new User();
// console.log(mango); // {}

// const poly = new User();
// console.log(poly); // {}
// ---------------------------------------------------------------------------------
// Конструктор класу

// Спосіб створення класу залежить від твоєї задачі.У нашому прикладі клас User представляє користувача,
//     тому ми додамо до нього поля для імені та пошти.

// Для ініціалізації екземпляра класу використовується метод constructor.

// Якщо його не визначити в явному вигляді, то буде створений конструктор за замовчуванням
//  — порожня функція, яка не змінює екземпляр класу.

// class User {
//   // Синтаксис оголошення методу класу
//   constructor() {
// 		// ...
//   }
// }

// Виклик класу з оператором new призводить до створення нового об'єкта й автоматичного виклику методу constructor.

// class User {
//   constructor() {
// 		console.log("constructor call")
//   }
// }

// const mango = new User(); // "constructor call"
// console.log(mango); // {}

// Аргументи, які передаються при виклику new User(), стають значеннями параметрів для методу constructor.

// class User {
//   constructor(name, email) {
//     console.log(name, email);
//   }
// }

// const mango = new User('Mango', 'mango@mail5555.com'); // "Mango mango@mail.com"
// console.log(mango); // {}

// Зверни увагу, що метод constructor викликається в контексті створюваного екземпляра.

// class User {
//   constructor(name, email) {
//     // Ініціалізація властивостей екземпляра
//     this.name = name;
//     this.email = email;
//   }
// }

// const mango = new User('Mango', 'mango@mail.com');
// console.log(mango); // { name: 'Mango', email: 'mango@mail.com' }

// const poly = new User('Poly', 'poly@mail.com');
// console.log(poly); // { name: 'Poly', email: 'poly@mail.com' }

// Таким чином, this усередині конструктора посилається на новостворений об'єкт.
// Це дозволяє надавати кожному об'єкту властивості з однаковими іменами, але різними значеннями.
// Властивості name та email називаються публічними властивостями, оскільки вони є власними властивостями об'єкта-екземпляра.
// ------------------------------------------------------------------------------
// Додай класу Car метод constructor, який приймає три параметри:

// brand - марка автомобіля
// model - модель автомобіля
// price - ціна автомобіля
// Клас Car повинен створювати об'єкт з одноіменними властивостями brand, model і price,
// які отримують свої значення з аргументів, переданих при створенні нового екземпляра за допомогою оператора new.
// Оголошений клас Car
// Клас Car має метод constructor
// class Car {
//   constructor(brand, model, price) {
//     this.brand = brand;
//     this.model = model;
//     this.price = price;
//   }
// }

// const myCar = new Car();

// console.log(new Car('Audi', 'Q3', 36000));
//  утвориться об'єкт {brand: "Audi", model: "Q3", price: 36000}
// console.log(new Car('BMW', 'X5', 58900));
//  утвориться об'єкт {brand: "BMW", model: "X5", price: 58900}
// console.log(new Car('Nissan', 'Murano', 31700));
//  утвориться об'єкт {brand: "Nissan", model: "Murano", price: 31700}
// -------------------------------------------------------------------------------------
// Об'єкт параметрів
// Клас може приймати велику кількість вхідних даних для властивостей майбутнього об'єкта.

// До них також можна застосувати патерн «Об'єкт параметрів», передаючи один об'єкт з логічно
// іменованими властивостями, замість непов'язаного набору аргументів.

// class User {
//   constructor(params) {
//     this.name = params.name;
//     this.email = params.email;
//   }
// }

// const mango = new User({
//   name: 'Mango',
//   email: 'mango@mail.com',
// });
// console.log(mango);
// { name: "Mango", email: "mango@mail.com" }
// ---------------------------------------------------------------------------------------------
// Виконай рефакторинг класу Car таким чином, щоб він приймав один параметр - об'єкт з властивостями brand, model і price.

// Оголошений клас Car
// Клас Car має метод constructor

// class Car {
//   constructor(brand, model, price) {
//     this.brand = brand;
//     this.model = model;
//     this.price = price;
//   }
// }

// class Car {
//   constructor(property) {
//     this.brand = property.brand;
//     this.model = property.model;
//     this.price = property.price;
//   }
// }

// const myCars = new Car({});

// console.log(new Car({ brand: 'Audi', model: 'Q3', price: 36000 }));
//  утвориться об'єкт {brand: "Audi", model: "Q3", price: 36000}
// console.log(new Car({ brand: 'BMW', model: 'X5', price: 58900 }));
//  утвориться об'єкт {brand: "BMW", model: "X5", price: 58900}
// console.log(new Car({ brand: 'Nissan', model: 'Murano', price: 31700 }));
//  утвориться об'єкт {brand: "Nissan", model: "Murano", price: 31700}
// ---------------------------------------------------------------------------------
// Методи класу

// Для роботи з властивостями майбутнього екземпляра використовуються методи класу.
// Методи класу — це функції, які будуть доступні екземпляру в його прототипі.
//  Вони оголошуються в довільному порядку після конструктора.
//  На відміну від синтаксису методів об'єкта (вони розділяються комою), методи класу не розділені жодними спеціальними символами.

// Розгляньмо приклад використання методів у класі User.

// class User {
//   constructor(params) {
//     this.name = params.name;
//     this.email = params.email;
//   }

//   // Метод getEmail
//   getEmail() {
// 		// ...
//   }

//   // Метод changeEmail
//   changeEmail(newEmail) {
// 		// ...
//   }
// }
// // Для доступу до властивостей у методах використовується ключове слово this,
// //     оскільки методи будуть викликані в контексті об'єкта-екземпляра.

// class User {
//   constructor(params) {
//     this.name = params.name;
//     this.email = params.email;
//   }

//   getEmail() {
//     return this.email;
//   }

//   changeEmail(newEmail) {
//     this.email = newEmail;
//   }
// }

// Після створення екземпляра можна використовувати оголошені методи класу,
//     які будуть звертатися до властивостей об'єкта, що їх викликав.

// const mango = new User({
// 	name: "Mango",
// 	email: "mango@mail.com"
// });

// console.log(mango.getEmail()); // "mango@mail.com"

// mango.changeEmail("new@mail.com");

// console.log(mango.getEmail()); // "new@mail.com"
// ----------------------------------------------------------------------------
// Додай класу Car два методи.

// getPrice() - повертає значення властивості price з об'єкта, який буде його викликати.
// changePrice(newPrice) - оновлює значення властивості price в об'єкта, який буде його викликати на значення параметра newPrice.
// В класі Car оголошений метод getPrice
// Метод getPrice повертає значення властивості price екземпляра класу, який його викликає
// В класі Car оголошений метод changePrice
// Метод changePrice змінює значення властивості price екземпляра класу, який його викликає

// class Car {
//   constructor(params) {
//     this.brand = params.brand;
//     this.model = params.model;
//     this.price = params.price;
//   }
// }

// class Car {
//   constructor(params) {
//     this.brand = params.brand;
//     this.model = params.model;
//     this.price = params.price;
//   }

//   getPrice() {
//     return this.price;
//   }
//   changePrice(newPrice) {
//     this.price = newPrice;
//   }
// }
// ----------------------------------------------------------------------------------------
// Прототип екземпляру

// Розглянемо для прикладу код класу User, який наразі має такий вигляд:

// class User {
//   constructor(params) {
//     this.name = params.name;
//     this.email = params.email;
//   }

//   getEmail() {
//     return this.email;
//   }

//   changeEmail(newEmail) {
//     this.email = newEmail;
//   }
// }

// const mango = new User({
// 	name: "Mango",
// 	email: "mango@mail.com"
// });

// console.log(mango.getEmail());  // “mango@mail.com”

// Якщо поглянути на структуру екземпляра класу User в інструментах розробника,
// може виникнути питання: "Де методи, які ми викликаємо?"

// Об'єктно-орієнтоване програмування в JavaScript побудоване на прототипному наслідуванні.
//  Методи класу не стають власними властивостями екземпляра.І це правильно, оскільки, на відміну від значень властивостей, вони не є унікальними.Це одна й та сама функція, яка викликається в контексті різних об'єктів. Немає сенсу копіювати методи для кожного екземпляра, враховуючи, що може існувати багато тисяч екземплярів.

// Методи класу додаються до спеціального об'єкта, який зберігається у властивості prototype самого класу.

// class User {
//   constructor(params) {
//     this.name = params.name;
//     this.email = params.email;
//   }

//   getEmail() {
//     return this.email;
//   }

//   changeEmail(newEmail) {
//     this.email = newEmail;
//   }
// }
// console.log(User.prototype); // {constructor: ƒ, getEmail: ƒ, changeEmail: ƒ}

// При створенні екземпляра через new, об'єкт, збережений у властивості prototype класу,
//  автоматично стає його прототипом.Це означає, що властивість[[Prototype]] екземпляра
//  отримує посилання на властивість prototype класу.

// Завдяки цьому об'єкт-екземпляр може використовувати методи класу, тобто властивості свого прототипу.
//  Також у цьому об'єкті зберігається посилання на метод constructor класу,
//   але це потрібно лише для внутрішніх механізмів класу і не має значення для нас.
// ----------------------------------------------------------------------------------------
// Приватні властивості
// Водій автомобіля натискає на педаль газу — і машина набирає швидкість.
//  Він може зручно та просто керувати системою клімату, бачить поточну швидкість на спідометрі тощо.
//  Водночас для такого зручного використання можливостей інтерфейсу всередині автомобіля виконується дуже багато дій і процесів.

//     Інкапсуляція — це парадигма ООП, яка передбачає приховування деталей внутрішньої реалізації класу від зовнішнього коду.
// Інкапсуляція реалізується приватними властивостями та методами, доступ до яких можна отримати тільки всередині класу.

// Інший розробник, який користується цим класом, має отримувати доступ тільки до публічного
// інтерфейсу — набору публічних властивостей і методів класу.

// Припустимо, що пошта користувача повинна бути недоступною для прямої зміни ззовні, тобто приватною.
//  Додаючи до імені властивості на початку символ #, ми робимо її приватною.Оголошення приватної властивості до ініціалізації в конструкторі є обов'язковим.

// class User {
//   // Необов'язкове оголошення публічних властивостей
//   name;
//   // Обов'язкове оголошення приватних властивостей
//   #email;

//   constructor(params) {
//     this.name = params.name;
//     this.#email = params.email;
//   }
// }

// const mango = new User({
//   name: 'Mango',
//   email: 'mango@mail.com',
// });
// console.log(mango.name); // "Mango"
// console.log(mango.#email); // Виникне помилка, це приватна властивість

// Для того щоб отримати або змінити значення приватної властивості використовуються публічні методи.

// class User {
//   name;
//   #email;

//   constructor(params) {
//     this.name = params.name;
//     this.#email = params.email;
//   }

//   getEmail() {
//     return this.#email;
//   }

//   changeEmail(newEmail) {
//     this.#email = newEmail;
//   }
// }

// const mango = new User({
//   name: 'Mango',
//   email: 'mango@mail.com',
// });

// console.log(mango.getEmail()); // "mango@mail.com"
// mango.changeEmail('mango@supermail.com');
// console.log(mango.getEmail()); // "mango@supermail.com"
// -------------------------------------------------------------------------------------
// Виконай рефакторинг класу Car таким чином, щоб властивість brand була приватною,
//     і додай два методи для публічного інтерфейсу, для читання і зміни цієї властивості.

// getBrand() - повертає значення приватної властивості brand.
// changeBrand(newBrand) - змінює значення приватної властивості brand на newBrand.
// Оголошений клас Car
// Властивість brand в класі Car оголошена приватною
// Конструктор класу приймає об'єкт з властивостями brand, model і price

// В екземпляра відсутня публічна властивість brand
// Метод getBrand() повертає значення приватної властивості brand
// Метод changeBrand("Honda") змінює значення приватної властивості brand на "Honda"

// class Car {
//   constructor(params) {
//     this.brand = params.brand;
//     this.model = params.model;
//     this.price = params.price;
//   }

//   getPrice() {
//     return this.price;
//   }

//   changePrice(newPrice) {
//     this.price = newPrice;
//   }
// }

// class Car {
//   #brand; // private property
//   constructor(params) {
//     this.#brand = params.brand;
//     this.model = params.model;
//     this.price = params.price;
//   }

//   getPrice() {
//     return this.price;
//   }

//   changePrice(newPrice) {
//     this.price = newPrice;
//   }

//   getBrand() {
//     return this.#brand;
//   }

//   changeBrand(newBrand) {
//     this.#brand = newBrand;
//   }
// }

// console.log(new Car({ brand: 'Audi', model: 'Q3', price: 36000 }));
//  утвориться об'єкт { model: "Q3", price: 36000 }
// console.log(new Car({ brand: 'bmw', model: 'X5', price: 58900 }));
//  утвориться об'єкт { model: "X5", price: 58900 }
// console.log(new Car({ brand: 'Nissan', model: 'Murano', price: 31700 }));
//  утвориться об'єкт { model: "Murano", price: 31700 }
// --------------------------------------------------------------------------
// Приватні методи

// Ти вже знаєш, як працюють публічні методи.Подивимось на це на прикладі класу User з приватною властивістю
// #email та публічною властивістю name.

// class User {
//   name;
//   #email;

//   constructor(params) {
//     this.name = params.name;
//     this.#email = params.email;
//   }

// Публічний метод для отримання електронної пошти
//   getEmail() {
//     return this.#email;
//   }

// Публічний метод для зміни електронної пошти
//   changeEmail(newEmail) {
//     this.#email = newEmail;
//   }
// }

// const mango = new User({
//   name: "Mango",
//   email: "mango@mail.com",
// });

// console.log(mango.getEmail()); // "mango@mail.com"
// mango.changeEmail("mango@supermail.com");
// console.log(mango.getEmail()); // "mango@supermail.com"

// Іноді потрібно не просто отримувати або змінювати адресу електронної пошти,
//     але й проводити певні дії, які мають бути приховані від "зовнішнього світу".

// Скажімо, кожен раз, коли електронна пошта змінюється, потрібно валідувати її формат.

// Це можна зробити за допомогою приватних методів. Додаючи до назви методу на початку символ #, ми робимо його приватним.

// class User {
//   name;
//   #email;

//   constructor(params) {
//     this.name = params.name;
//     this.#email = params.email;
//   }

// Публічний метод для отримання електронної пошти
//   getEmail() {
//     return this.#email;
//   }

// Публічний метод для зміни електронної пошти
//   changeEmail(newEmail) {
//     if (this.#validateEmail(newEmail)) {
//       this.#email = newEmail;
//     } else {
//       console.log('Invalid email format');
//     }
//   }

// Приватний метод для валідації електронної пошти
//   #validateEmail(email) {
//     return email.includes('@');
//   }
// }

// const mango = new User({
//   name: 'Mango',
//   email: 'mango@mail.com',
// });

// Спробуємо змінити електронну пошту
// mango.changeEmail('newmail.com'); // "Invalid email format"
// mango.changeEmail('new@mail.com');
// console.log(mango.getEmail()); // "new@mail.com"

// Прямий виклик приватного методу ззовні призведе до помилки
// mango.#validateEmail('test'); // Помилка

// У цьому прикладі приватний метод #validateEmail забезпечує додаткову логіку для валідації електронної пошти.
// Цей метод не доступний ззовні класу, тому користувачі(або інші розробники) не можуть його викликати напряму.
//  Вони можуть лише використовувати публічний метод changeEmail, який у свою чергу використовує приватний метод для валідації.
// Таким чином, ми інкапсулюємо внутрішню логіку й забезпечуємо безпеку та стабільність роботи класу.
// -----------------------------------------------------------------------------
// Геттери і сеттери
// Геттери і сеттери — це спеціальний синтаксис оголошення методів для взаємодії з властивостями.
// Геттер і сеттер імітують звичайну публічну властивість класу, але дозволяють взаємодіяти з іншими властивостями зручнішим способом.

// class User {
//   #email;

//   constructor(params) {
//     this.name = params.name;
//     this.#email = params.email;
//   }

//   // Геттер email
//   get email() {
//     return this.#email;
//   }

//   // Сеттер email
//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// У прикладі вище оголошені геттер і сеттер email.Щоб оголосити геттер і сеттер,
//     потрібно поставити перед ім'ям властивості відповідні ключові слова — get і set. Всередині цих методів:

// повертаємо значення приватної властивості #email за допомогою геттера
// змінюємо її значення за допомогою сеттера

// Також вважається гарною практикою називати геттери і сеттери так само, як і властивість,
//     з якою вони працюють.Це спрощує читання коду та його розуміння.
//     Коли інші розробники бачать геттер чи сеттер, який називається так само, як і властивість,
//     вони можуть легко здогадатися, що цей метод служить для доступу до конкретної властивості.Наприклад,
//         геттер і сеттер для приватної властивості #email найлогічніше називати просто email, як у прикладі вище.

// Геттер і сеттер повинні називатися однаково.
// Краще називати геттери і сеттери так само, як і властивість, з якою вони працюють.
// Геттер може існувати без сеттера, так само як і сеттер без геттера.

// Розгляньмо приклад: геттер виконується при спробі отримати значення властивості, а сеттер — при спробі її змінити.

// const mango = new User({
// 	name: "Mango",
// 	email: "mango@mail.com"
// });

// console.log(mango.email); // mango@mail.com

// mango.email = "mango@supermail.com";

// console.log(mango.email); // mango@supermail.com

// Звертаючись до mango.email, викликається геттер get email() {...} і виконується його код.
// При спробі запису mango.email = "mango@supermail.com" викликається сеттер set email(newEmail) {... },
// і рядок "mango@supermail.com" буде значенням параметра newEmail.

// Перевага в тому, що це методи.Отже, під час запису або читання можна виконати додатковий код з
// будь - якими перевірками, на відміну від виконання цієї ж операції безпосередньо з властивістю.

// set email(newEmail) {
//     if (newEmail === "") {
//         console.log("Помилка! Пошта не може бути порожнім рядком!");
//         return;
//     }

//     this.#email = newEmail;
// }
// Геттери і сеттери доречно використовувати для простих операцій читання та зміни значення властивостей,
//     особливо приватних, як їх публічний інтерфейс.Для роботи з властивістю, яка зберігає масив або об'єкт, вони не підійдуть.
// ------------------------------------------------------------------------------------------------------------
// Виконай рефакторинг класу Car.Додатково до приватної властивості #brand зроби приватними властивості model і price.
// Стандартизуй публічний інтерфейс класу, замінивши вже оголошені методи на геттери та сеттери brand, model і price,
// для взаємодії з приватними властивостями.

// Оголошений клас Car
// В класі Car оголошена приватна властивість brand
// В класі Car оголошена приватна властивість model
// В класі Car оголошена приватна властивість price
// Конструктор класу приймає параметр params, який є об'єктом з властивостями brand, model і price
// В класі Car оголошений геттер brand
// В класі Car оголошений сеттер brand
// В класі Car оголошений геттер model
// В класі Car оголошений сеттер model
// В класі Car оголошений геттер price
// В класі Car оголошений сеттер price

// class Car {
//   #brand;

//   constructor(params) {
//     this.#brand = params.brand;
//     this.model = params.model;
//     this.price = params.price;
//   }

//   getBrand() {
//     return this.#brand;
//   }

//   changeBrand(newBrand) {
//     this.#brand = newBrand;
//   }

//   getModel() {
//     return this.model;
//   }

//   updateModel(newModel) {
//     this.model = newModel;
//   }

//   getPrice() {
//     return this.price;
//   }

//   setPrice(newPrice) {
//     this.price = newPrice;
//   }
// }

// class Car {
//   #brand;
//   #model;
//   #price;
//   constructor(params) {
//     this.#brand = params.brand;
//     this.model = params.model;
//     this.price = params.price;
//   }

//   get brand() {
//     return this.#brand;
//   }

//   set brand(newBrand) {
//     this.#brand = newBrand;
//   }

//   get model() {
//     return this.#model;
//   }

//   set model(newModel) {
//     this.#model = newModel;
//   }

//   get price() {
//     return this.#price;
//   }

//   set price(newPrice) {
//     this.#price = newPrice;
//   }
// }
// -----------------------------------------------------------------------------------------------
// Статичні властивості
// Крім публічних і приватних властивостей майбутнього екземпляра, у класі можна оголосити його власні властивості.
//     Властивості, що доступні тільки класові, але не його екземплярам — це статичні властивості.Вони корисні для зберігання інформації, що стосується класу.
// Статичні властивості оголошуються в тілі класу.Перед ім'ям властивості додається ключове слово static.
// Статичні властивості можна використовувати як у методах класу, так і поза класом.

// class MyClass {
// 	static myProp = "value";
// }
// console.log(MyClass.myProp); // "value"

// У екземпляра немає доступу до статичних властивостей класу.

// class MyClass {
// 	static myProp = "value";
// }

// const inst = new MyClass();
// console.log(inst.myProp); // undefined

// Додамо класу користувача приватну властивість role — його роль, що визначає набір прав,
//     наприклад: адміністратор, редактор, звичайний користувач тощо.Можливі ролі користувачів
//     будемо зберігати як статичну властивість roles — об'єкт із властивостями.

// class User {
//   static roles = {
//     admin: "admin",
//     editor: "editor",
// 		basic: "basic"
//   };

//   #email;
//   #role;

//   constructor(params) {
//     this.#email = params.email;
//     this.#role = params.role || User.roles.basic;
//   }

//   get role() {
//     return this.#role;
//   }

//   set role(newRole) {
//     this.#role = newRole;
//   }
// }

// const mango = new User({
//   email: "mango@mail.com",
//   role: User.roles.admin,
// });

// console.log(mango.role); // "admin"
// mango.role = User.roles.editor;
// console.log(mango.role); // "editor"
// ----------------------------------------------------------------------------------------
// Виконай рефакторинг класу Car.Додай публічну статичну властивість maxPrice зі значенням
//  число 50000 - максимально допустима ціна автомобіля.

// Додай сеттеру price перевірку значення параметра newPrice, що передається.Якщо воно більше за maxPrice,
//     сеттер нічого не робить, а якщо менше або дорівнює, то перезаписує ціну автомобіля.

// Під оголошенням класу ми додали ініціалізації екземплярів і виклики методів, щоб показати,
//     як будуть використовуватися геттери і сеттери price.

// Оголошений клас Car
// Клас Car містить статичну властивість maxPrice
// Значення статичної властивості maxPrice - це число 50000
// Екземпляр не містить властивості maxPrice
// В класі Car оголошений геттер price
// В класі Car оголошений сеттер price
// Виклик сеттера price в екземпляра класу, зі значенням аргументу меншим за значення maxPrice, змінює властивість #price
// Виклик сеттера price в екземпляра класу, зі значенням аргументу більшим за значення maxPrice, не змінює властивість #price

// class Car {
//   #price;
//   constructor(params) {
//     this.#price = params.price;
//   }

//   get price() {
//     return this.#price;
//   }

//   set price(newPrice) {
//     this.#price = newPrice;
//   }
// }

// const audi = new Car({ price: 35000 });
// console.log(audi.price); // 35000

// audi.price = 49000;
// console.log(audi.price); // 49000

// audi.price = 51000;
// console.log(audi.price); // 49000

// class Car {
//   static maxPrice = 50000;
//   #price;

//   constructor(params) {
//     this.#price = params.price;
//   }

//   get price() {
//     return this.#price;
//   }

//   set price(newPrice) {
//     if (newPrice <= Car.maxPrice) {
//       this.#price = newPrice;
//     } else {
//       console.log(
//         `Ціна ${newPrice} перевищує максимальне значення ${Car.maxPrice}`
//       );
//     }
//   }
// }

// const audi = new Car({ price: 35000 });
// console.log(audi.price); // 35000

// audi.price = 49000;
// console.log(audi.price); // 49000

// audi.price = 51000;
// console.log(audi.price); // 49000
// --------------------------------------------------------------------------------------
// Статичні методи
// У класі можна оголосити не тільки методи майбутнього екземпляра,
//     а й статичні методи.Статичні методи — це методи, доступні тільки класу.Вони можуть бути публічні та приватні.

// Синтаксис оголошення статичних методів майже аналогічний статичним властивостям. Єдина відмінність — значенням буде метод.

// class MyClass {
//   static myMethod() {
//     console.log("A static method");
//   }
// }

// MyClass.myMethod(); // "A static method"

// Додамо у клас User:
// статичну властивість takenEmails для зберігання зайнятих пошт користувачів
// статичний метод isEmailTaken, який перевіряє, чи доступна пошта
// Під час ініціалізації екземпляра в конструкторі класу будемо додавати пошту в список зайнятих.

// class User {
//   static #takenEmails = [];

//   static isEmailTaken(email) {
//     return User.#takenEmails.includes(email);
//   }

//   #email;

//   constructor(params) {
//     this.#email = params.email;
//     User.#takenEmails.push(params.email);
//   }
// }

// const mango = new User({ email: "mango@mail.com" });

// console.log(User.isEmailTaken("poly@mail.com")); // false
// console.log(User.isEmailTaken("mango@mail.com")); // true

// Особливість статичних методів
// Під час їх виклику ключове слово this посилається на сам клас.Це означає,
//     що статичний метод може отримати доступ до статичних властивостей класу, але не до властивостей екземпляра.
// Це логічно, адже статичні методи викликає сам клас, а не його екземпляри.
// -----------------------------------------------------------------------------
// Додай класу Car публічний статичний метод checkPrice(price), що приймає ціну автомобіля.
// Метод повинен порівняти значення параметра price і приватної статичної властивості maxPrice.

// Якщо ціна автомобіля перевищує максимальну, метод повинен повернути рядок "Error! Price exceeds the maximum".
// В іншому випадку метод повинен повернути рядок "Success! Price is within acceptable limits".
// Під оголошенням класу ми додали ініціалізацію екземпляра і виклики методів, щоб показати,
//     як буде використовуватися метод checkPrice(price).

// Оголошений клас Car
// Клас Car містить статичний метод checkPrice(price)
// Виклик Car.checkPrice(36000) повертає рядок "Success! Price is within acceptable limits"
// Виклик Car.checkPrice(18000) повертає рядок "Success! Price is within acceptable limits"
// Виклик Car.checkPrice(64000) повертає рядок "Error! Price exceeds the maximum"
// Виклик Car.checkPrice(57000) повертає рядок "Error! Price exceeds the maximum"

// class Car {
//   static #maxPrice = 50000;

//   constructor(params) {
//     this.price = params.price;
//   }
// }

// const audi = new Car({ price: 36000 });
// const bmw = new Car({ price: 64000 });

// class Car {
//   static checkPrice(price) {
//     if (price > Car.#maxPrice) {
//       return `Error! Price exceeds the maximum`;
//     } else {
//       return `Success! Price is within acceptable limits`;
//     }
//   }

//   static #maxPrice = 50000;

//   constructor(params) {
//     this.price = params.price;
//   }
// }

// const audi = new Car({ price: 36000 });
// const bmw = new Car({ price: 64000 });

// console.log(Car.checkPrice(audi.price)); // "Success! Price is within acceptable limits"
// console.log(Car.checkPrice(bmw.price)); // "Error! Price exceeds the maximum"
// console.log(Car.checkPrice(audi.price)); // "Success! Price is within acceptable limits"
// console.log(Car.checkPrice(bmw.price)); // "Error! Price exceeds the maximum"
// --------------------------------------------------------------------------------------
// Наслідування класів
// Ключове слово extends дозволяє реалізувати наслідування класів, коли один клас(дочірній, похідний)
//  наслідує властивості й методи іншого класу(батьківського).
// Розгляньмо приклад:

// class Parent {}

// class Child extends Parent {
//   // ...
// }
// У виразі class Child extends Parent дочірній клас Child наслідує (розширює) від батьківського класу Parent.

// Це означає, що ми можемо оголосити базовий клас, який зберігає загальні характеристики й методи для групи похідних класів,
//     які наслідують властивості й методи батьківського, але також додають свої унікальні.

//         Уявімо, у застосунку є користувачі з різни"basic",ми ролями: адміністратор, копірайтер, контент-менеджер тощо.
// У кожного типу користувача є набір загальних характеристик, наприклад, пошта і пароль, але також є й унікальні.
// Створивши незалежні класи для кожного типу користувача, ми отримаємо дублювання загальних властивостей і методів.
// Якщо необхідно змінити, наприклад, назву властивості, доведеться проходити по всіх класах, а це незручно й вимагає багато часу.

// Замість цього можна:
// створити загальний клас User, який буде зберігати набір загальних властивостей і методів
// після чого створити класи для кожного типу користувача, які наслідують цей набір від класу User
// За потреби змінити щось спільне, достатньо буде змінити тільки код класу User.
// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
// 	// Тіло класу ContentEditor
// }

// const editor = new ContentEditor("mango@mail.com");
// console.log(editor); // { #email: "mango@mail.com" }
// console.log(editor.email); // "mango@mail.com"
// Клас ContentEditor наслідує від класу User його конструктор, геттер і сеттер email, а також приватну властивість #email.
// -------------------------------------------------------------------------------------
// У застосунку потрібен адміністратор з можливістю додавати пошти користувачів у чорний список.

// Оголоси клас Admin, який наслідує від класу User
// Додай класу Admin публічну статичну властивість role(рівень доступу),
//     значення якої — це об'єкт {BASIC:  SUPERUSER: "superuser"}
// Оголошений клас Admin
// Клас Admin наслідується від класу User
// Клас Admin містить публічну статичну властивість role
// Звернення до Admin.role.BASIC повертає рядок "basic"
// Звернення до Admin.role.SUPERUSER повертає рядок "superuser"
// class User {
//   constructor(email) {
//     this.email = email;
//   }

//   get email() {
//     return this.email;
//   }

//   set email(newEmail) {
//     this.email = newEmail;
//   }
// }

// class User {
//   constructor(email) {
//     this.email = email;
//   }

//   get email() {
//     return this.email;
//   }

//   set email(newEmail) {
//     this.email = newEmail;
//   }
// }
// class Admin extends User {
//   static role = { BASIC: 'basic', SUPERUSER: 'superuser' };
// }
// --------------------------------------------------------------------------
// Конструктор дочірнього класу
// У конструкторі дочірнього класу необхідно викликати спеціальну функцію super(args) — це псевдонім конструктора батьківського класу.
// В іншому випадку при спробі звернутися до this у конструкторі дочірнього класу виникне помилка.
// Під час виклику конструктора батьківського класу передаємо необхідні йому аргументи для ініціалізації властивостей.

// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
//   constructor(params) {
//     // Виклик конструктора батьківського класу User
//     super(params.email);

//     this.posts = params.posts;
//   }
// }

// const editor = new ContentEditor({
// 	email: "mango@mail.com",
// 	posts: []
// });
// console.log(editor); // { #email: "mango@mail.com", posts: [] }
// // console.log(editor.email); // "mango@mail.com"
// ------------------------------------------------------------------------------------
// Додай класу Admin метод constructor, який приймає один параметр params- об'єкт налаштувань з двома властивостями email і access.
//  Додай класу Admin публічну властивість access, значення якої буде передаватися під час виклику конструктора.

// Щоб показати, як буде використовуватися клас Admin, ми додали ініціалізацію екземпляра під оголошенням класу.

// Оголошений клас Admin
// Клас Admin наслідує від класу User
// Клас Admin містить публічну статичну властивість role
// Клас Admin містить метод constructor з параметром params
// В класі Admin в конструкторі для властивості email використовується звернення до конструктора батьківського класу
// Звернення до Admin.role.BASIC повертає рядок "basic"
// Звернення до Admin.role.SUPERUSER повертає рядок "superuser"
// class User {
//   email;

//   constructor(email) {
//     this.email = email;
//   }

//   get email() {
//     return this.email;
//   }

//   set email(newEmail) {
//     this.email = newEmail;
//   }
// }

// class Admin extends User {
//   static role = {
//     BASIC: "basic",
//     SUPERUSER: "superuser",
//   };
// }

// const mango = new Admin({
//   email: "mango@mail.com",
//   access: Admin.role.SUPERUSER,
// });

// console.log(mango.email); // "mango@mail.com"
// console.log(mango.access); // "superuser"

// class User {
//   email;

//   constructor(email) {
//     this.email = email;
//   }

//   get email() {
//     return this.email;
//   }

//   set email(newEmail) {
//     this.email = newEmail;
//   }
// }

// class Admin extends User {
//   access;
//   static role = {
//     BASIC: 'basic',
//     SUPERUSER: 'superuser',
//   };
//   constructor(params) {
//     super(params.email);
//     this.email = params.email;
//     this.access = params.access;
//   }
// }

// const mango = new Admin({
//   email: 'mango@mail.com',
//   access: Admin.role.SUPERUSER,
// });

// console.log(mango.email); // "mango@mail.com"
// console.log(mango.access); // "superuser"
// --------------------------------------------------------------------
// Методи дочірнього класу
// Дочірній клас може використовувати методи та властивості батьківського класу.
// Крім цього, у дочірньому класі можна оголошувати методи, які будуть доступні тільки його екземплярам.

// // Уявімо, що вище є оголошення класу User

// class ContentEditor extends User {
//   constructor(params) {
//     super(params.email);
//     this.posts = params.posts;
//   }

//   addPost(post) {
//     this.posts.push(post);
//   }
// }

// const editor = new ContentEditor({
// 	email: "mango@mail.com",
// 	posts: []
// });

// console.log(editor); // { #email: "mango@mail.com", posts: [], addPost: f }

// editor.addPost("post-1");
// editor.addPost("post-2");
// console.log(editor.posts); // ['post-1', 'post-2']

// У прикладі бачимо, що ContentEditor успадковує клас User.
// User — це базовий клас, який має приватну властивість #email.
// ContentEditor розширює клас User і має власну властивість posts.
// Клас ContentEditor також має метод addPost, який дозволяє додавати нові повідомлення до posts.
// Метод addPost — це метод дочірнього класу ContentEditor . Він буде доступний тільки екземплярам ContentEditor.
// -------------------------------------------------------------------------------------
// Додай класу Admin наступні властивості і методи.

// Публічну властивість blacklistedEmails для зберігання чорного списку поштових адрес користувачів.
// Значення за замовчуванням — це порожній масив.
// Публічний метод blacklist(email) для додавання пошти у чорний список.
//  Метод повинен додавати значення параметра email в масив, що зберігається у властивості blacklistedEmails.
// Публічний метод isBlacklisted(email) для перевірки пошти у чорному списку.
//  Метод повинен перевіряти наявність значення параметра email в масиві, що зберігається
//  у властивості blacklistedEmails, і повертати true або false.
// Після оголошення класу ми додали ініціалізацію екземпляра і виклики методів у тій послідовності,
// в якій твій код перевірятимуть тести.Будь ласка, нічого там не змінюй.

// Оголошений клас Admin
// Клас Admin наслідує від класу User
// Клас Admin містить публічну властивість blacklistedEmails
// Клас Admin містить публічний метод blacklist
// Клас Admin містить публічний метод isBlacklisted
// Після виклику mango.blacklist("poly@mail.com") значення властивості blacklistedEmails - це масив ["poly@mail.com"]
// Виклик mango.isBlacklisted("mango@mail.com") повертає false
// Виклик mango.isBlacklisted("poly@mail.com") повертає true
// class User {
//   email;

//   constructor(email) {
//     this.email = email;
//   }

//   get email() {
//     return this.email;
//   }

//   set email(newEmail) {
//     this.email = newEmail;
//   }
// }
// class Admin extends User {
//   static role = {
//     BASIC: "basic",
//     SUPERUSER: "superuser",
//   };

//   constructor(params) {
//     super(params.email);
//     this.access = params.access;
//   }
// }

// const mango = new Admin({
//   email: "mango@mail.com",
//   access: Admin.role.SUPERUSER,
// });

// console.log(mango.email); // "mango@mail.com"
// console.log(mango.access); // "superuser"

// mango.blacklist("poly@mail.com");
// console.log(mango.blacklistedEmails); // ["poly@mail.com"]
// console.log(mango.isBlacklisted("mango@mail.com")); // false
// console.log(mango.isBlacklisted("poly@mail.com")); // true

// class User {
//   email;

//   constructor(email) {
//     this.email = email;
//   }

//   get email() {
//     return this.email;
//   }

//   set email(newEmail) {
//     this.email = newEmail;
//   }
// }

// class Admin extends User {
//   static role = {
//     BASIC: 'basic',
//     SUPERUSER: 'superuser',
//   };

//   constructor(params) {
//     super(params.email);
//     this.access = params.access;
//     this.blacklistedEmails = []; // Initialize blacklistedEmails as an empty array
//   }

//   blacklist(email) {
//     this.blacklistedEmails.push(email); // Add email to blacklistedEmails array
//   }

//   isBlacklisted(email) {
//     return this.blacklistedEmails.includes(email); // Check if email is in blacklistedEmails array
//   }
// }
// const mango = new Admin({
//   email: 'mango@mail.com',
//   access: Admin.role.SUPERUSER,
// });

// console.log(mango.email); // "mango@mail.com"
// console.log(mango.access); // "superuser"

// mango.blacklist('poly@mail.com');
// console.log(mango.blacklistedEmails); // ["poly@mail.com"]
// console.log(mango.isBlacklisted('mango@mail.com')); // false
// console.log(mango.isBlacklisted('poly@mail.com')); // true
