// Вправи для закріплення методів масивів
// Чудово, що ти вирішив поглибити свої знання щодо методів масивів у JavaScript!
// Практика - це найкращий спосіб освоїти нові концепції.Ось кілька вправ, які допоможуть тобі закріпити матеріал:

// Базові вправи
// Створити масив з 10 випадкових чисел від 1 до 100. Використай метод Math.random() для генерації випадкових чисел.
// Знайти суму всіх елементів масиву. Використай метод reduce().
// Знайти середнє арифметичн еелементів масиву.
// Перевірити, чи всі елементи масиву є числами. Використай метод every().
// Перевірити, чи хоча б один елемент масиву є парним. Використай метод some().
// Відфільтрувати парні числа з масиву. Використай метод filter().
// Створити новий масив, де кожен елемент буде подвоєний. Використай метод map().
// Відсортувати масив за зростанням. Використай метод sort().
// З'єднати всі елементи масиву в один рядок, розділені комою. Використай метод join().
// Видалити всі дублікати з масиву. Використай метод Set для створення унікального набору елементів.
// -----------------------------------------------------------------------------
// 1 Створити масив з 10 випадкових чисел від 1 до 100. Використай метод Math.random() для генерації випадкових чисел.
// const Numbers = [];
// for (let i = 0; i < 10; i++) {
// Генеруємо випадкове число від 0 (включно) до 1 (не включно)
//   const Number = Math.random();
// Перетворюємо випадкове число в діапазон від 1 до 100
//   const randomInt = Math.floor(Number * 100) + 1;
// Додаємо згенероване число до масиву
//   Numbers.push(randomInt);
// }
// console.log(Numbers);

// 2 Знайти суму всіх елементів масиву. Використай метод reduce().

// const summNumber = Numbers.reduce((acc, namber) => {
//   return acc + namber;
// }, 0);
// console.log(summNumber);

// 3 Знайти середнє арифметичн еелементів масиву.
// const AverangeNamber = summNumber / Numbers.length;
// console.log(AverangeNamber);

// 4 Перевірити, чи всі елементи масиву є числами. Використай метод every().
// const nambers = [32, 57, 68, 30, 82, 5, 20, 5, 50, 23];
// const isAllNumbers = (Numbers) => {
//   return Numbers.every((item) => typeof item === 'number');
// };
// console.log(isAllNumbers(Numbers));

// 5 Перевірити, чи хоча б один елемент масиву є парним. Використай метод some().

// const hasEvenNumbers = (Numbers) => {
//   return Numbers.some((number) => number % 2 === 0);
// };
// console.log(hasEvenNumbers(Numbers));

// 6 Відфільтрувати парні числа з масиву. Використай метод filter().
// const filteredNumbers = (Numbers) => {
//   return Numbers.filter((namber) => namber % 2 === 0);
// };
// console.log(filteredNumbers(Numbers));

// 7 Створити новий масив, де кожен елемент буде подвоєний. Використай метод map().

// const newNumbers = (Numbers) => Numbers.map((namber) => namber * 2);
// console.log(newNumbers(Numbers));

// 8  Відсортувати масив за зростанням. Використай метод sort().
// const sortedNumbers = Numbers.sort((a, b) => a - b);
// console.log(Numbers);

// 9 З'єднати всі елементи масиву в один рядок, розділені комою. Використай метод join().

// const lengthNambers = (Numbers) => Numbers.join(',');

// console.log(lengthNambers(Numbers));

// 10 Видалити всі дублікати з масиву. Використай метод Set для створення унікального набору елементів.
// const uniqueNumbers = (Numbers) => [...new Set(Numbers)];
// console.log(uniqueNumbers(Numbers));
// --------------------------------------------------------------------------------
// Середній рівень
// Створити масив об'єктів, де кожен об'єкт представляє користувача з полями name і age.
//  Відсортувати масив за віком за спаданням.
// Дано масив рядків. Знайти найдовший рядок.
// Дано масив об'єктів товарів з полями name і price. Знайти найдорожчий товар.
// Створити новий масив, де кожен елемент буде об'єктом з полями originalValue
//   (початкове значення) і newValue(значення, помножене на 2).
// Згрупувати масив об'єктів за якою-небудь властивістю (наприклад, за першою літерою імені).
//  Використай об'єкт для збереження груп.

// 1  Створити масив об'єктів, де кожен об'єкт представляє користувача з полями name і age.

// const nameAge = [
//   { name: 'Jon', age: 25 },
//   { name: 'Alise', age: 22 },
//   { name: 'Patrik', age: 24 },
//   { name: 'Susan', age: 23 },
// ];
// console.log(nameAge);

// 2  Відсортувати масив за віком за спаданням.

// const sortedArray = nameAge.sort((a, b) => a.age - b.age);
// console.log(sortedArray);

// 3  Дано масив рядків. Знайти найдовший рядок.
// const myStrings = ['grapefruit', 'apple', 'banana', 'orange', 'cappustofell'];

// function findLongestString(strings) {
//   return strings.reduce(
//     (longest, current) => (longest.length > current.length ? longest : current),
//     ''
//   );
// }
// ----------------------------sort---------------------------------
// console.log(findLongestString(myStrings));

// const longSorted = myStrings.sort((a, b) => b.length - a.length)[0];

// console.log(longSorted);

// function SortLong(myStrings) {
//   let newString = '';
//   for (let i = 0; i < myStrings.length; i++) {
//     if (myStrings[i].length > newString.length) {
//       newString = myStrings[i];
//     }
//   }
//   return newString;
// }

// console.log(SortLong(myStrings));

// 4 Дано масив об'єктів товарів з полями name і price. Знайти найдорожчий товар.
// const products = [
//   { name: 'Ford', price: 25000 },
//   { name: 'Mazda', price: 22000 },
//   { name: 'Lanos', price: 24000 },
//   { name: 'Toyota', price: 23000 },
// ];

// let maxPrice = products[0].price;
// let sortedProducts = products[0];

// for (let i = 1; i < products.length; i++) {
//   if (products[i].price > maxPrice) {
//     maxPrice = products[i].price;
//     sortedProducts = products[i];
//   }
// }
// const sortedProducts = products.toSorted((a, b) => a - b);

// console.log(products);
// console.log(sortedProducts);
// --------------------------------------------------------------
// 5  Створити новий масив, де кожен елемент буде об'єктом з полями originalValue
// (початкове значення) і newValue(значення, помножене на 2).

// const originalArray = [1, 2, 3, 4, 5];

// const newArray = originalArray.map((value) => ({
//   originalValue: value,
//   newValue: value * 2,
// }));

// console.log(newArray);

// 6  Згрупувати масив об'єктів за якою-небудь властивістю (наприклад, за першою літерою імені).

// const users = [
//   { name: 'Andriy', age: 30 },
//   { name: 'Olena', age: 25 },
//   { name: 'Boris', age: 35 },
//   { name: 'Anna', age: 28 },
// ];

// const groupedUsers = users.reduce((acc, user) => {
//   const firstLetter = user.name[0].toUpperCase();
//   if (!acc[firstLetter]) {
//     acc[firstLetter] = [];
//   }
//   acc[firstLetter].push(user);
//   return acc;
// }, {});

// console.log(groupedUsers);
// ----------------------------------------------------------------------------
// Завдання 1:
// У вас є масив чисел. Потрібно збільшити кожне число на 10 та отримати новий масив.
// const numbers = [5, 10, 15, 20, 25];
// Підказка: використовуйте метод .map()
// const itemNamber = 10;
// const arreyNamber = numbers.map((number) => number + itemNamber);
// console.log(arreyNamber);
// -------------------------------------------------------------------------------
// Завдання 2:
// Отримати парні числа
// Потрібно відфільтрувати парні числа з масиву.
// const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// Підказка: використовуйте метод .filter()
// const filteredNumbers = numbers.filter((number) => !(number % 2));
// console.log(filteredNumbers);
// ----------------------------------------------------------------------------------
// Завдання 3:
// Підрахувати суму чисел
// Обчисліть суму всіх чисел у масиві.
// const numbers = [1, 2, 3, 4, 5, 6];
// Підказка: використовуйте метод .reduce()
// const summNumber = numbers.reduce((acc, item) => (acc += item), 0);
// console.log(summNumber);
// ------------------------------------------------------------------------------------
// Завдання 4:
// Перетворити масив об'єктів у масив імен
// Є масив об'єктів користувачів. Потрібно отримати масив їхніх імен.
// const users = [
//   { name: 'John', age: 25 },
//   { name: 'Jane', age: 30 },
//   { name: 'Bob', age: 20 },
// ];
// Підказка: використовуйте метод .map()
// const userName = users.map((user) => user.name);
// console.log(userName);
// -----------------------------------------------------------------------------------
// Завдання 5:
//  Перевірити наявність числа більше 50
// У масиві чисел потрібно перевірити, чи є хоч одне число більше 50.
// const numbers = [10, 20, 30, 40, 60];
// Підказка: використовуйте метод .some()
// const sortedArray = numbers.some((number) => number > 50);
// console.log(sortedArray);
// -------------------------------------------------------------------------------------
// Завдання 6:
// Перевірити, чи всі числа більше 10
// Перевірте, чи всі числа в масиві більше за 10.
// const numbers = [12, 15, 22, 33, 45];
// Підказка: використовуйте метод .every()
// const arreyNamber = numbers.every((number) => number > 10);
// console.log(arreyNamber);
// -------------------------------------------------------------------------------------
// Завдання 7:
// Знайти об'єкт за віком
// У масиві об'єктів користувачів знайдіть перший об'єкт, де вік більше 20 років.
// const users = [
//   { name: 'John', age: 18 },
//   { name: 'Jane', age: 25 },
//   { name: 'Bob', age: 20 },
// ];
// Підказка: використовуйте метод .find()
// const searchAgeUser = users.find((user) => user.age > 20);
// console.log(searchAgeUser);
// ---------------------------------------------------------------------------------------
// Завдання 8:
//  Отримати індекс елемента
// Знайдіть індекс першого числа більше 50 у масиві.
// const numbers = [10, 20, 30, 40, 60];
// Підказка: використовуйте метод .findIndex()
// const searchInOneNumber = numbers.findIndex((number) => number > 50);
// console.log(searchInOneNumber);
// ------------------------------------------------------------------------------------------
// Завдання 9:
// Створити новий масив унікальних значень
// Є масив із повторюваними значеннями. Потрібно створити новий масив, у якому залишаться тільки унікальні значення.
// const items = ['apple', 'banana', 'apple', 'orange', 'banana', 'pear'];
// Підказка: використовуйте метод .filter() разом з .indexOf()
// const uniceArrey = items.filter((item, index, self) => {
//   return self.indexOf(item) === index;
// });

// console.log(uniceArrey);

// Створення нового масиву з унікальними значеннями за допомогою .filter() та .indexOf()
// Розуміння задачі:
// Ми маємо масив items, який містить повторювані елементи.Наша мета – створити новий масив,
//     де кожен елемент зустрічається лише один раз.

// Розв'язання:
// Для вирішення цієї задачі ми скористаємося двома методами масивів у JavaScript: .filter() та .indexOf().
// .filter(): Цей метод створює новий масив, який містить всі елементи, для яких функція зворотного виклику повертає значення true.
// .indexOf(): Цей метод повертає перший індекс елемента в масиві, або -1, якщо елемент не знайдено.
// Логіка роботи:
// Ми створюємо новий масив, який спочатку буде порожнім.
// Перебираємо кожен елемент вихідного масиву.
// Для кожного елемента ми перевіряємо, чи його індекс у новому масиві дорівнює -1.
// Якщо індекс дорівнює -1, це означає, що елемент ще не зустрічався в новому масиві, тому ми додаємо його туди.
// Якщо індекс не дорівнює -1, то елемент вже є в новому масиві, і ми його пропускаємо.
// Код:
// JavaScript
// const items = ['apple', 'banana', 'apple', 'orange', 'banana', 'pear'];
// const uniqueItems = items.filter((item, index, self) => {
//     return self.indexOf(item) === index;
// });
// console.log(uniqueItems); // Виведе: ['apple', 'banana', 'orange', 'pear']
// Використовуйте цей код обачно.
// Пояснення код:
// items.filter((item, index, self) => {...}): Ця частина коду застосовує метод.filter() до масиву items.
// Функція зворотного виклику приймає три аргументи:
// item: поточний елемент масиву.
// index: індекс поточного елемента.
// self: сам масив.
//     self.indexOf(item) === index: Ця умова перевіряє, чи перше входження елемента item у
// масиві self збігається з його поточним індексом.Якщо так, то елемент зустрічається вперше і додається до нового масиву.
// Чому це працює:
// .indexOf() гарантує, що ми додаємо в новий масив тільки перше входження кожного елемента.
// .filter() створює новий масив, відфільтровуючи всі елементи, які відповідають умові.
// Результат:
// В результаті виконання цього коду змінна uniqueItems буде містити масив['apple', 'banana', 'orange', 'pear'],
//     де кожен фрукт зустрічається тільки один раз.
// ------------------------------------------------------------------------------------------------
// Завдання 10:
// Об'єднати всі рядки в один
// Потрібно об'єднати всі елементи масиву рядків в один рядок через кому.
// const words = ['Hello', 'world', 'this', 'is', 'JavaScript'];
// Підказка: використовуйте метод .join()
// const lengthWords = words.join(',');
// console.log(lengthWords);
// ---------------------------------------------------------------------------------------------------
// Завдання 11:
// Перевести всі слова в верхній регістр
// Потрібно отримати новий масив, де кожен елемент (слово) буде у верхньому регістрі.
// const words = ['hello', 'world', 'javascript', 'fun'];
// Підказка: використовуйте метод .map() і .toUpperCase()
// const arrayWords = words.map((word) => word.toUpperCase());
// console.log(arrayWords);
// ---------------------------------------------------------------------------------------------------------
// Завдання 12:
// Зворотне сортування масиву
// Є масив чисел. Потрібно відсортувати його в зворотному порядку.
// const numbers = [1, 4, 3, 2, 5];
// Підказка: використовуйте метод .sort() і порівняльну функцію
// const sortedNumbers = numbers.sort((a, b) => b - a);
// console.log(sortedNumbers);
// ------------------------------------------------------------------------------------------------------
// Середній рівень
// Завдання 1:
//  Знайти середній вік
// Є масив об'єктів користувачів з властивістю age. Потрібно обчислити середній вік користувачів.
// const users = [
//   { name: 'John', age: 25 },
//   { name: 'Jane', age: 30 },
//   { name: 'Bob', age: 20 },
//   { name: 'Alice', age: 35 },
// ];
// Підказка: використовуйте .map() для отримання масиву віків та .reduce() для підсумку

// const newArray = users.map((user) => user.age);
// const averangeAge = newArray.reduce((acc, item) => (acc += item), 0);
// const averageAgeUsers = averangeAge / users.length;

// console.log(averageAgeUsers);
// -----------------------------------------------------------------------------------------------------
// Завдання 2:
//  Перетворити масив у об'єкт
// Є масив об'єктів із властивостями id і name.
// Потрібно перетворити цей масив у об'єкт, де ключами будуть id, а значеннями — відповідні name.

// const items = [
//   { id: 1, name: 'Apple' },
//   { id: 2, name: 'Banana' },
//   { id: 3, name: 'Orange' },
// ];
// Підказка: використовуйте метод .reduce()
// const object = items.reduce((acc, item) => {
//   acc[item.id] = item.name;
//   return acc;
// }, {});
// console.log(object);
// -------------------------------------------------------------------------------------------------------
// Завдання 3:
// Створити масив унікальних значень із вкладених масивів
// Є масив із вкладеними масивами. Потрібно отримати новий масив, де будуть всі унікальні значення.
// const arrays = [
//   [1, 2, 3],
//   [2, 3, 4],
//   [4, 5, 6],
// ];
// Підказка: використовуйте .flat() і .filter() для уникнення дублікатів
// Розгортаємо вкладені масиви в один
// const flattenedArray = arrays.flat();
// console.log(flattenedArray);

// Фільтруємо унікальні значення
// const uniqueValues = flattenedArray.filter(
//   (value, index, self) => self.indexOf(value) === index
// );

// console.log(uniqueValues);
// ---------------------------------------------------------------------------------------------------------
// Завдання 4:
// Групування користувачів за віком
// Є масив об'єктів користувачів із властивістю age. Потрібно згрупувати їх за віком в об'єкт,
// де ключами будуть віки, а значеннями — масиви імен користувачів із відповідним віком.
// const users = [
//   { name: 'John', age: 25 },
//   { name: 'Jane', age: 30 },
//   { name: 'Bob', age: 25 },
//   { name: 'Alice', age: 30 },
// ];
// Підказка: використовуйте .reduce() для групування
// const groupedUsers = users.reduce((acc, user) => {
// Якщо в акумуляторі ще немає групи за віком, створюємо її
//   if (!acc[user.age]) {
//     acc[user.age] = [];
//   }

// Додаємо ім'я користувача до масиву за відповідним віком
//   acc[user.age].push(user.name);

//   return acc;
// }, {});

// console.log(groupedUsers);

// ---------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------
//  !!!!!!!Завдання на reduce практика!!!!!!!
// Повернути об'єкт у якому вказується кількість тегів
// const tweets = [
//   { id: '000', likes: 5, tags: ['js', 'nodejs'] },
//   { id: '001', likes: 2, tags: ['html', 'css'] },
//   { id: '002', likes: 17, tags: ['html', 'js', 'nodejs'] },
//   { id: '003', likes: 8, tags: ['css', 'react'] },
//   { id: '004', likes: 0, tags: ['js', 'nodejs', 'react'] },
// ];

// const tagObject = tweets
//   .flatMap((tweet) => tweet.tags)
//   .reduce((acc, item) => {
//     acc[item] = (acc[item] || 0) + 1;
//     return acc;
//   }, {});

// console.log(tagObject); // Виведе: {js: 3, nodejs: 3, html: 2, css: 2, react: 2}
// -------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------
